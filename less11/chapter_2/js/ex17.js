// Пример 17 - Раскрывающееся меню

// Создание содержимого html-страницы из объекта JS:
let data = {
    "Овощи": {
        "огурцы": 5,
        "помидоры": 3
    },
    "Фрукты": {
        "красные": {
            "клубника": 2,
            "малина": 4
        },
        "зеленые": {
            "яблоко": 6,
            "лайм": 2
        }
    }
}

function createTree(container, obj) {
    document.querySelector(container).append(createUl(obj))
}

function createUl(obj) {
    if (!Object.keys(obj).length) return
    let ul = document.createElement('ul')
    for (let key in obj) {
        let li = document.createElement('li')

        if (!isNaN(obj[key]))
            li.textContent = key + ` ${obj[key]}`
        else
            li.textContent = key

        let childrenUl = createUl(obj[key])
        if (childrenUl) {
            li.append(childrenUl)
        }
        ul.append(li)
    }
    return ul
}

createTree('body', data); // Конец создания содержимого html


// Для начала, обернём весь наш текст в тег span - для того, чтобы было удобнее работать и хоть как-то можно было отслеживать нажатия

let ul = document.querySelector('ul') // нашли самый первый большой список ul,который у нас уже создан
for (let li of ul.querySelectorAll('li')) { // внутри ul ищем все li и проходимся по ним циклом
    let span = document.createElement('span') // создали DOM-элемент span, заголовок Овощи тоже находится в теге li вместе с вложенными строками
    li.prepend(span) // span добавился отдельно перед текстом Овощи в самое начало текущего li в цикле потому что сначала идет текст, а потом следующий вложенный список

    // Выглядит это сейчас примерно так:
    // <span></span>
    // Овощи

    span.append(span.nextSibling) // Выбираем пустой отдельный span, и внутрь него с помощью append в конец с помощью метода nextSibling помещаем текстовый узел. "span.nextSibling" означает взять следующий узел справа относительно span на этом же уровне DOM-дерева (а там как раз располагается текст)

    // Выглядит это стало вот так:
    // <span>Овощи</span>
    // <span>огурцы 5</span>
    // <span>помидоры 3</span>
    // Циклом мы обернули все текстовые поля в span

    // Соседние узлы (сиблинги, брат, сестра)
    // Кроме как двигаться сверху вниз и снизу вверх по дереву, JavaScript также позволяет двигаться в горизонтальном направлении между соседними узлами, т.е. узлами, которые имеют одного родителя.
    // Свойство nextSibling служит для обращения к следующему узлу, расположенному по иерархии на одном уровне с исходным узлом (элементом) веб-документа.

    // Для перемещения между соседними узлами в JavaScript нам доступны следующие свойства:
    // nextSibling - для перемещения слева направо, т.е. к следующему соседу (сиблингу). Если соседа справа нет, то данное свойство возвращает значение null.
    // previousSibling - для перемещения справа налево, т.е. к предыдущему соседу (сиблингу). Если соседа слева нет, то данное свойство возвращает значение null.
    // Статья: https://itchief.ru/javascript/walking-dom
}

// Далее отловим клики по нашим строкам списка
ul.onclick = function (event) { // переменная ul уже заданна выше, у ней ловим событие клика
    if (event.target.tagName != 'SPAN') return; // исключаем все клики кроме тега span - прерываем функцию
    // Свойство tagName содержит имя тега в верхнем регистре (большими буквами)

    // так как верхнее условие не сработало, то получается что это наш span который нас интересует
    let childrenContainer = event.target.parentNode.querySelector('ul');
    // подцепились к цели, затем parentNode - уходим выше на родительский узел - и в нём ищем  вложенный список querySelector('ul'), то есть тыкнули в span, и нашли родителя span'а, который его содержит, и у него нашли вложенный список

    if (!childrenContainer) return // если такой переменной нет, то есть у текущей строки-заголовка нет дочерних тегов ul, то выходим из обработчика

    // Если верхнее условие не выполнилось и вложенный ul есть, то причем/открываем его:
    childrenContainer.hidden = !childrenContainer.hidden // свойству hidden устанавливаем противоположное значение - инвертируем, либо скрываем, либо показываем

}

// В результате Овощи, Фрукты, красные, зеленые при щелчке скрывают свой вложенный список
// При щелчке на конечном узле списка не имеющем вложенного списка - ничего не происходит

// Таким образом можно из любого объекта любой вложенности сделать меню имеющее сворачивающееся / разворачивающееся под-меню.

// Из комментариев:
// Эту задачу можно решить намного проще, не вводя тег <span>. Всего 5 строк кода и работает точно так же:

function SergeyKudritskiy () {
    document.querySelector('ul').onclick = function(e) {

      if (e.target.tagName!='LI') return;

      let childrenContainer = e.target.querySelector('ul');

      if (childrenContainer) childrenContainer.hidden = !childrenContainer.hidden;

    }
}

/*

* Вопрос: Какое свойство позволяет проверить название тега у элемента?
* Ответ: event.target.tagName

*/