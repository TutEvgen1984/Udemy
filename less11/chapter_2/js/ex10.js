// Чтобы как в  библиотеке JQuery сделать более компактную запись нахождения элемента в виде
// ${'.block'}.innerHTML = "a"
// в JQuery в данном случае находится 1 или все элементы с классом block и сразу меняем значение у innerHTML (там не innerHTML, там другая запись)
// вместо JScrypt: let checkbox = document.querySelector('.theme-checkbox') и прохождения по всем элементам с помощью цикла for of

class $ { //$ значок не рекомендуется использовать так как он используется в других библиотеках, но так как мы их подключать не будем сейчас мы его будем использовать
    constructor(selector, where = document) {
        // selector - это 1-й параметр, такой же, как в CSS
        // where = document - 2-й параметр, по умолчанию document если параметр не передадим. Сюда можно написать например класс block, и тогда поиск начнется с класса блок, а не с document

        this.self = where.querySelector(selector);
        // Такой записью мы сделали тот же самый querySelector
        // это - доступ к нахождению одного первого элемента, этот способ работает быстрее чем querySelectorAll

        this.elems = where.querySelectorAll(selector);
        // это доступ к нахождению всех элементов.
    }

    // Создадим метод, который будет делать с каждым элементом массива elems ту функцию, которую мы передадим
    each(callback) { // создали метод each, у которого в качестве аргумента callback, в который мы будем передавать анонимную функцию, в которой будут написаны действия, которые будут выполняться для каждого найденного элемента
        for(let elem of this.elems) { // проходимся по всем найденным элементам
            callback(elem) //  для каждого элемента выполняем переданную функцию, в качестве аргумента функции подставляется нацеленный элемент elem
        }
    }

    // создадим метод, позволяющий назначать обработчики событий на несколько элементов
    on(event, callback) { // event это параметр click - тип события
        for(let elem of this.elems) { // проходимся по всем найденным элементам
           elem.addEventListener(event, callback)
        }
        return this; // этот код позволяет  привязывать несколько событий последовательно для группы  элементов ( смотри ниже). Это - возврат своего собственного значения из этого метода on()
    }

}

new $('.block').self.innerHTML = "Новый текст"
// На html-старице "Новый текст" появился вместо "Text"
// теперь у нас такая же запись как на JQuery, только у нас теперь new впереди
// с такой записью мы  подцепились к классу блок и изменили его innerHTML
// это аналогично записи:
document.querySelector('.block').innerHTML = "Новый текст"
// вроде бы кажется, что сэкономили всего несколько символов

// Если в консоли напечатать:
// new $('input')
// $ {self: input, elems: NodeList(3)}
// получили объект $ у которого в свойстве self находится только 1 input так как сработал querySelector ищущий всего 1 DOM-объект
// elems: NodeList(3) означает что в это свойство записалось 3 найденных input'а, так как использовали querySelectorAll

new $('input').each(function(e) {
    e.style.fontSize = '20px'
    e.value = '1'
})
// function(e) аргумент e можно было назвать как угодно, вместо него буду подставлен DOM-элемент elem, а ещё точнее input в нашем случае
// в результате шрифт у каждого input'a увеличился до 20, а значение value изменилось на 1
// теперь нам не нужно каждый раз создавать цикл снаружи чтобы проходить по всем найденным элементам
//  с помощью этого класса теперь мы находим один или несколько элементов ( в зависимости от того как нам требуется) и работаем как с единым целым

new $('p', new $('div').self).self.innerHTML = "новый текст"
// нашли тег p в теге div, и изменили его значение на 'новый текст'

new $('p', new $('div').self).each(function(elem) {
    elem.innerHTML = 1;
})
// нашли тег p в теге div, и изменили его значение на '1'

new $('div').on('click', function() {
    this.classList.toggle('bgc');
    }
)
// теперь при щелчке по div'у он окрашивается в зелёный цвет, при повторном клике окрашивание исчезает

new $('input').on('focus', function() {
    this.style.backgroundColor = 'tomato'
})
// теперь при щелчке на input, у него будет проявляться цвет.  для того чтобы убрать цвет существует специальный метод blur

new $('input').on('blur', function() {
    this.style.backgroundColor = ''
})
// теперь при потере фокуса цвет будет исчезать

// далее благодаря return this  можно сократить верхний код:
new $('input').on('focus', function() {
    this.style.backgroundColor = 'tomato'
}).on('blur', function() {
    this.style.backgroundColor = ''
})
// получилось работающий код покраски и снятия покраски для группы input

// далее сделаем стандартным методом то, что мы сделали выше и посмотрим на разницу 
let items = document.querySelectorAll('input')
for(let item of items) {
    item.addEventListener('focus', function() {
        this.style.backgroundColor = 'tomato'
    })
    item.addEventListener('blur', function() {
        this.style.backgroundColor = ''
    })
}
// получился тот же самый результат
