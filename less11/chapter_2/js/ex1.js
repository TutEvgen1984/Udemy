
/*

Статья: https://learn.javascript.ru/introduction-browser-events

Самые популярные события:

События мыши:
click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
mouseover / mouseout – когда мышь наводится на элемент / покидает элемент.
mousedown / mouseup – когда нажали кнопку / отжали кнопку мыши на элементе.
mousemove – при движении мыши.

События на элементах управления:
submit – пользователь отправил форму <form>.
focus – пользователь фокусируется на элементе, например нажимает на <input>.

Клавиатурные события:
keydown и keyup – когда пользователь нажимает / отпускает клавишу.

События документа:
DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

*/

// Первый метод - смотри в html у кнопки 1 метод onclick как атрибут

// Второй способ - querySelector и onclick как метод
document.querySelector('.btn').onclick = function() { // Безымянная функция
    alert('Клик!'); // Сработал alert с текстом Клик!
    console.log('клик в консоль'); //  консоль: клик в консоль
}
// Удобство этого метода в том, что в фигурных скобках безымянной функции можно писать много кода, расположенного в нескольких строках. Поэтому такой метод наиболее предпочтителен

//  Второй способ использования ключевого слова this
document.querySelector('.btn2').onclick = function() {
    alert(this.innerHTML) // Получили: пустота
    //  пустоту мы получили потому что input это НЕ парный тег, он одинарный и внутри него нет HTML кода между открывающим и закрывающим тегом. А вот например для кнопки button существует html-код
    // innerHTML  это тот текстовый код, который располагается внутри тега input
}

document.querySelector('.button5').onclick = function() {
    alert(this.innerHTML) // Получили: Кнопка 5
    //  так как мы применили обработчик события к кнопке, внутри которой есть  html-код, то с помощью this.innerHTML получили надпись внутри кнопки
}

// Функция в качестве обработчика событий. Способ 1:
function addText() {
    alert("Add Text") //  При нажатии на кнопку №6 срабатывает alert("Add Text")
}

// Функция в качестве обработчика событий. Способ 2:
document.querySelector('.button7').onclick = addText // в этом способе наоборот не нужно ставить скобки у функции, если скобки поставить, то код перестаёт работать. это связано с тем, что если поставить круглые скобки, то функция сразу начинает пытаться исполняться, а если мы передаём только её название, то она будет присвоена в качестве обработчика события
// получили сработавший alert("Add Text")
// это основное ключевое отличие - в первом способе круглые скобки нужны, во втором наоборот не нужны
// Главный недостаток этих двух способов - это невозможность повесить несколько обработчиков на одно событие
// Для устранения этого недостатка существует метод AddEventlistener

// Третий метод обработчика событий:

// Создадим 3 функции, которые мы хотим назначить затем в качестве обработчика для одного события
function addText1() {
    alert('Первый текст')
}

function addText2() {
    alert('Второй текст')
}

function addText3() {
    alert('Третий текст')
}

// Эти функции похожи только как пример, на самом деле эти функции могут быть  совершенно разными про логике и смыслу

document.querySelector('.button8').onclick = addText1 // это мы уже изученным методом добавили обработку события
document.querySelector('.button8').addEventListener('click', addText2)
document.querySelector('.button8').addEventListener('click', addText3)
// Получили: Первый текст, Второй текст, Третий текст

document.querySelector('.button9').onclick = addText1
document.querySelector('.button9').onclick = addText2
document.querySelector('.button9').onclick = addText3

