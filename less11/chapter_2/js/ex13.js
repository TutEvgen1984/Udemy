// Пример 13 - Делегирование
// Всплытие и перехват события позволяют реализовать один из самых важных приёмов разработки - делегирование.
// Идея заключается в том, чтобы имея таблицу (родитель) и 1000 ячеек (1000 потомков), присвоить обработчик 1 раз к родителю и затем вычислить цель, и уже только на ней выполнить обработчик. Это очень сильно скажется на оптимизации.

// Далее реализуем делегирование на JS. Имеем 12 ячеек таблицы (их может быть 1000), при выделении элемента Ячейка либо в ячейке может быть еще отдельный элемент типа span, нам нужно покрасить ячейку цветом (присвоим класс)

let currentTd // идентифицировали, это будет текущий элемент td
table.onclick = function (e) { // щелкнув на любое содержимое таблицы за счет всплытия применили к родителю событие onclick и используем его объект события в виде переменной 'e'
    let td = e.target.closest('td') // у родителя table применяем метод target, который вычислит изначальный элемент по которому щелкнул пользователь, затем к полученному применяем closest('td') потому что нам нужно красить именно ячейку, а не любой элемент который может находиться в ней, например строчные span, i. em... Если же там других тегов нет, то closest вернёт сам себя

    if(!td) return // если элемент td не был найден, то мы выходим - прекращаем обработку события

    if(!table.contains(td)) return // если в нашей таблице ячейка td не содержится, то мы так же выходим из обработчика потому, что у нас может быть несколько разных таблиц, и не факт, что ячейка td, которую мы сейчас нашли, относится именно к этой таблице

    hover(td) // вызов функции для подсветки ячейки, принимающая ячейку в качестве параметра, функция будет описана ниже

    function hover(td) {
        if(currentTd) { // если у нас уже есть какая-то ячейка в переменной, то мы будем убирать с неё подсветку
            currentTd.classList.remove('bgc'); // удаляем фон
        }

        // если такой ячейки currentTd у нас не было:
        currentTd = td;
        currentTd.classList.add('bgc');
    }
}