/* * {color: rgb(34, 223, 91);} */
/* * (звёздочка) означает - применить свойства для любого тэга, в результате цвет у всего ТЕКСТА стал другой */

/* h1 {color: brown;}  */
/* Несмотря на то что в главном документе h1 написан с id, в нему все равно применяется изменение цвета. */

/* - Через ТОЧКУ(.) мы обращаемся к классу,
   - Через РЕШЕТКУ шарп (#) обращаемся к идентификатору,
   - Если написать имя тэга, например DIV, то мы применим свойства ко всем тэгам DIV на странице */

#p1 {
    background-color: transparent;
    /* Покрасил фон абзаца р1 прозрачным цветом */
    color: crimson;
    /* изменил цвет текста */
    border: 3px darkblue dashed;
    /*  граница шириной 3 пикселя пунктирной чертой определенного цвета */
    border-radius: 10px 20px 30px 40px;
    /* радиус скругления 10-20-30-40 пикс для каждого из 4 углов по часовой стрелке, а если указать только одно значение, то получится это значение радиуса для всех 4-х углов */
    border-top-color: chartreuse;
    /* отдельный цвет верхней границы */
}

#h1keyboard {
    background-color: rgb(224, 185, 26);
}

/* идентификатор id стиля для заголовка Сочетания клавиш  */
/* Вообще использование id это плохо потому что он имеет ограничения заключающиеся в том, что для одного элемента мы можем использовать несколько классов и в коде html применять один и тот же класс несколько раз для разных тегов, а id может быть упомянут коде html только один раз!!!. id лучше использовать в html для якорей для быстрого перемещения, и в JavaScript */

.keyboard {
    background-color: rgb(134, 238, 30);
}

/* Класс стиля для Сочетания клавиш  */

kbd {
    background-color: rgb(212, 201, 171);
}

/* Стиль для всех тегов kbd (сочетания клавиш клавиатуры) */

div {
    background-color: deeppink;
}

/* Если этот стиль Div перенести ниже нижних двух, то он не перекрасит все divы собой потому что дивы с тайтлом имеют больший приоритет и не дают этому обычному с низшим приоритетом себя перекрасить  */

div[title="text1"] {
    background-color: brown;
}

/* Здесь мы обратились к определённому div имеющему всплывающую подсказку text1 */

div[title] {
    background-color: darkgoldenrod;
}

/* Здесь мы обратились ко всем элементам div на странице, у которых прописан title. В результате закрасился весь задний фон страницы от левого края до правого. При этом те div у которых title не прописан остаются нетронутыми стилем */

span {
    background-color: crimson;
}

/* В результате закрасился задний фон за текстом обернутым в тег span, как будто закрасили только текст маркером */

code {
    background-color: gray;
}

/* Закрашиваем у кода задний фон */

.bgimg {
    background-image: url(../img/Красный\ воин.png);
    /* Добавляем картинку на задний фон дива + задаём чтобы картинка повторялась по y сверху вниз */
    background-repeat: repeat-y;
    /* задний_фон-повторение: повторять по у */
    /* Если не задать высоту и ширину, то при удалении текста не появится никаких блоков и фонов, а чтобы они всегда были нужно задать height и width */
    height: 50px;
    /* (h50 интер) высота закрашивания 50 пикселей  */
    width: 850px;
    /* (w150) ширина всего блока див 150 пикселей */
    border: 1px solid red;
    /* порядок атрибутов не важен. Мы задали границу блока */
    /* Если в f12 навести на бк, то увидим 152х52 потому что граница добавляет по 1 пикселю со всех сторон */
    border-top-width: 5px;
    /* дополнительное свойство */
    border-right-width: 20px;
    /* дополнительное свойство */
}

/* Section 2: Язык CSS. Решение задание пункта 18: */
/* Моё изначальное плохое решение задания (закомментрованно): */
/* .circle_1_red {
    background-color: red;
    height: 150px;
    width: 150px;
    border: 1px solid red;
    border-radius: 50%;
    }

.circle_2_yello {
    background-color: yellow;
    height: 150px;
    width: 150px;
    border: 1px solid yellow;
    border-radius: 50%;
    }

.circle_3_green {
    background-color: green;
    height: 150px;
    width: 150px;
    border: 1px solid green;
    border-radius: 50%;
    } */

/* Правильное решение: */

.svetofor div

/* Свойства применятся для всех элементов div внутри класса svetofor (на любом уровне вложенности) */
    {
    height: 150px;
    width: 150px;
    border-radius: 50%;
}

.red {
    background-color: red;
}

.yello {
    background-color: yellow;
}

.green {
    background-color: green;
}

.svetofor-p p

/* Свойства применятся для всех элементов p внутри класса svetofor-p (на любом уровне вложенности) */
    {
    height: 150px;
    width: 150px;
    border-radius: 50%;
}

p {
    font-family: Arial;
    /* Набрали ff и интер. serif это шрифт по умолчанию, он с засечками, а sans-serif это без засечек по краям, а monospace это шрифт с одинаковой шириной букв */
    font-size: 15px;
    /* fs25 интер */
    font-weight: 400;
    /* fw, 400 это normal, 700 это уже болд */
    line-height: 30px;
    /* lh30px, это высота строк при учете что текст посередине */
    text-align: center;
    /* Выравнивание текста по центру */
    text-decoration: underline;
    /* оформление текста подчеркивание */
    text-transform: capitalize;
    /* capitalize делает каждое слово с большой буквы, uppercase делает все буквы заглавными */
}

/* a {text-decoration: none;} убрали подчеркивание у всех ссылок на странице */

.no_marker {
    list-style-type: none;
}

/* Сделали для отдельного списка вид такой чтобы не было никаких маркеров строк */

/* 20. Блочная модель документа. */



.box {
    width: 150px;
    height: 150px;
    border: 1px solid black;
}

.box1 {
    background-color: crimson;
    margin: 10px;
    /* внешний отступ со всех сторон 10 пикс */
    padding: 5px;
    /* Внутренний отступ 5 пикселей по всем сторонам. При этом внутренняя часть все равно остаётся 150 пикселей + бордер, в итоге прямоугольник автоматически увеличивается */
}

.box2 {
    background-color: blue;
    margin: 10px;
    /* внешний отступ со всех сторон 10 пикс */
    /* Особенность в том, что на f12 видно что нижний отступ верхнего квадрата накладывается на верхний отсуп нижнего, это свойство css схлопываться, то есть расстояние считается края одного блока от края другого а не от их маржинов, и в итоге берётся наибольший */
    padding: 5px;
    box-sizing: border-box;
    /* box-sizing - изменение размеров коробок. Не даёт внешнему квадрату увеличиваться при увеличивающемся паддинге и бордере, вместо этого чем больше падинг и бордер, тем внутрений квадрат меньше */
}

/* * {box-sizing: border-box;} не даст пэддингам и блокам изменять внешние размеры всех блоков */

.box3 {
    background-color: burlywood;
    margin: 20px 40px;
    /* внешний отступ сверху и снизу 20 пикс, 40 пикс слева и справа */
}

.box4 {
    background-color: cornflowerblue;
    margin: 20px 40px 30px;
    /* внешний отступ сверху 20 пикс, 40 пикс слева и справа? 30 пикс снизу */
}

.box5 {
    background-color: chocolate;
    margin: 10px 20px 30px 60px;
    /* внешний отступ по часовой стрелке: сверху 10 пикс, 20 справа, 30 снизу, 60 слева */
}

.box6 {
    background-color: chocolate;
    box-sizing: border-box;
    margin-top: 20px;
    /* mt20 */
    margin-left: 30px;
    /* ml30 */
    margin-right: 40px;
    /* mr40 */
    margin-bottom: 20px;
    /* mb20 */
    /* padding: 10px; p10 */
    padding-top: 10px;
    /* pt10 */
    padding-left: 20px;
    /* pl20 */
    padding-right: 30px;
    /* pr20 */
    padding-bottom: 40px;
    /* pb20 */
}

.box7 {
    background-color: chocolate;
    box-sizing: border-box;
    margin: 20px 40px 20px 30px;
    padding: 10px 30px 40px 20px;
}

/* 21. Пседоклассы и псевдоэлементы: */

.default {
    cursor: default;
}

/* при наведении курсора - стрелочка мышки по умолчанию */

.pointer {
    cursor: pointer;
}

/* установили так, чтобы при наведении показывалась курсор рука вместо стрелочки */

.crosshair {
    cursor: crosshair;
}

/* курсор - перекрестие */

.help {
    cursor: help;
}

/* курсор справка */

.move {
    cursor: move;
}

/* курсор перемещения */

.progress {
    cursor: progress;
}

/* курсор процесс загрузки */

.text {
    cursor: text;
}

/* курсор наедения на текст */

.wait {
    cursor: wait;
}

/* курсор ожидания (похож на прогресс только кружок большой крутящийся и без стрелочки) */

/* Пседоклассы: */

a:hover {
    text-decoration: none;
    /* при наведении исчезает подчеркивание и синий цвет ссылка */
    color: red;
    /* при наведении текст становится красным */
}

/* hover это пседокласс который срабатыает при наведении мышкой. Определяет стиль элемента при наведении на него курсора мыши, но при этом элемент еще не активирован, иными словами кнопка мыши не нажата.  */

p:hover {
    text-decoration: none;
    /* при наведении исчезает подчеркивание и синий цвет текста абзаца */
    color: red;
    /* при наведении текст становится красным */
}

ul li:nth-child(3) {
    color: green;
}

/* Псевдокласс :nth-child используется для добавления стиля к элементам на основе нумерации в дереве элементов. Это мы применили ко всем ul. nth child это "n-ый ребёнок" */

.child4 li:nth-child(4) {
    color: red;
}

/* А это мы применили к списку с определенным классом */
/* Важно. Запись делается так же как сложная запись для div которая была при решении задачия про светофор (строка 75) */

.childodd li:nth-child(odd) {
    color: red;
}

/* нечетные строки */

.childeven li:nth-child(even) {
    color: red;
}

/* нечетные строки */

.childlast li:last-child {
    color: red;
}

/* последний ребенок */

.childfirst li:first-child {
    color: red;
}

/* первый ребенок */

table tr:nth-child(even) {
    background-color: blue;
    color: white;
}

/* пометили каждую четную строку tr в таблице */

/* Псевдоэлементы: */

/* Пседоэлемент before: */
p.before_and_after::before {
    content: "Псевдоэлемент before \00A9  ";
    /* для css для значко нужно искать отдельный код, код значков html с &впереди не работает. Справочник CSS символов в яндексе, и каждый символ длжен впереди иметь "\"  */
    color: azure;
    font-weight: bold;
    background-color: blue;
}

/* Тэг р с классом before + псевдоэлемент before с содержимым Текст, который вставляется перед содержимым р и имеет другое оформление. При этом его нельзя выбрать в отличии от простого текста.
Если написать p::before, то получим предзапись перед всеми р на странице */

/* Псевдоэлемент after":" */
p.before_and_after::after {
    content: " Спевдоэлемент After";
    font-weight: bold;
}

/* Конец 21. */

/* 22. Основы CSS Flexbox: */

div.flexbox1 {
    /*   display: block; - блоки выводятся на экран один под другим сверху вниз (по умолчанию так всегда для div`ов) */
    font-size: 40pt;
    margin: 20px;
    /* применяется не к каждому блоку, а к всей куче блоков */
    display: flex;
    /* блоки выводятся на экран слева направо*/
    flex-wrap: wrap;
    /* Блоки теперь перескакивают когда не влазиют. Указывает, следует ли флексам располагаться в одну строку или можно занять несколько строк. Если перенос строк допускается, то свойство также позволяет контролировать направление, в котором выкладываются строки.
    Wrap (свернуть, обтекать) = Флексы выстраиваются в несколько строк если блоки не влазиют в ширину окна, их направление задаётся свойством flex-direction. */
}

div.flexbox2 {
    font-size: 20pt;
    display: flex;
    /* это даёт возможность даже вертикальные блоки выравнивать по вертикали и горизонтали, на block такой возможности нет*/
    flex-direction: column;
    /* блоки выведутся сверу вниз первоначально */
    /* flex-direction: row;  блоки выведутся горизонтально в ряд (это можно было не писать так как они и так при display: flex выводятся в ряд */
}

div.flexbox3 {
    font-size: 20pt;
    display: flex;
    flex-wrap: wrap;
    /* Если убрать wrap, то рисутеся  любом случае  1 ряд и появляется полоска прокрутки снизу */

    justify-content: flex-start;
    /* Сдвигает всё влево к началу блоков как бы к северо-западу */

    /* justify-content: flex-end; */
    /* Сдвигает всё вправо к концу страницы как бы к юго-востоку*/

    /* justify-content: space-around;  */
    /* Оставит оступы по всем сторонам страницы и между блоками  */

    /* justify-content: space-between;
    раздвигает элементы к краям страницы */
}

div.flexbox4 {
    height: 500px;
    border: 5px solid black;
    font-size: 30pt;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    /* Блоки выравниваются по ширине к центру относительно родительского элемента */

    align-items: flex-end;
    /* высоте к нижней границе */

    /* align-items: center; блоки выравниваются по высоте к центру */
}

.flexbox4 div:nth-child(6) {
    align-self: center;
    /* здесь мы блок 6 отцентрировали по центру относительно своего блока в то время как остальные имеют  align-items: flex-end */
}

div.flexbox5 {
    height: 500px;
    border: 5px solid black;
    margin: 10%;
    font-size: 30pt;
    display: flex;
    flex-wrap: wrap;
    /* align-content: center; Вертикальное выравнивание содержимого по центру родительского блока, при этом по горизонтали прилипают к левому краю */

    /* align-content: space-between; разносит боки к верхней и нижней части в случае если они не входят по ширине, типа расположить равномерно между верхней и нижней границей */

    /* align-content: space-evenly; Выравнивание по вертикали. Все отступы сверху и снизу одинаковые */

    align-content: space-around;
    /* Сверху и сснизу отступы от краёв блока меньше чем отступы между самими элементами */
}

/* Конец 22. */