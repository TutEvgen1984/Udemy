console.log("Раздел 4.1. Введение в JavaScript. Работа с консолью разработчика, создание переменных")

console.log('5+7') /* можно ставить одинарные и двойные кавычки */

console.log(5+7) /* в консоли вывелось "12" */

// console.log('10+7') закомментировали строку и в результате мы ничего в консоли не видим

/* Комментарий
на 3 
строки */

console.log('---')

let name = 5 /* Создаём переменную. Переменная не долждна начинаться с цифр  */
var str = "10" /* если встретили в коде переменную var, то это - устаревший идентификатор, который заменили на let в 2015 году */
// тип переменных - число или текст, ява-скрипт их автоматически распознает

// переменная типа булева логика, логические переменные:
let boolean = true
let boolean2 = false
// 3 типа переменных: 
// 1. числовые,
// 2. строковае (текстовые)
// 3. логические
// Это - 3 основыных типа переменных, с помощью которых делаетсая практически всё

let name2=9.5/5.5 /* поддерживается деление, результат будет дробным с точкой. Кроме того - числа надо писать с точкой, а не с запятой */
console.log(name2) /* Вывелось в коннсоль 1.7272727272727273 */

let a=5
console.log(a)
a++ /* прибавление к переменной "a" единицы */
console.log(a) /* в консоли появилось: 6 */
// если написать ++ после переменной и в консоли нажать интер, то мы увидим значение переменной без операции прибавления. Но если именно вывести значение переменной то увидим с прибавлением 

++a /* такая запись даёт в консоли с помощью интер сразу результат с прибавлением единицы к переменной */
console.log(a) /* в консоли: 7 */

let b=30
b+=2 /* запись эквивалентна b=b+2 . Здесь переменная, операция, равно, и значение на которое будем выполнять операцию. Применяется тогда, когда нужно одну и ту же переменную изменить на какое-то значение */
console.log(b) /* в консоли: 32 */

// "str1"+"str2" в консоли дают результат str1str2 , то есть два текста скрепленные друг с другом

let c1="str1" 
let c2="str2"
let c3=c1+c2
console.log(c3) /* в консоль вывелось склеивание строк str1str2 */

let c="str1" 
c+="str2"
console.log(c) /* в консоль вывелось склеивание строк str1str2, результат такой же что и выше, только компактнее*/

let d=5+'str3' /* число 5 преобразуется в текст и склеится со строкой */
console.log(d) /* в консоли результат = 5str3 */

let d2=d+28
console.log(d2) /* в консоли результат = 5str328 (произошла операция склейки текста, а не математическая операция). Если на какой-то стадии число пребразовалось в текст, то оно дальше идет как текст */

let e=5+'2'
console.log(e) /* в консоли видим результат 52. Это текст потому что одно из слагаемых было текстом) */
// Это называется конкатенация

// Нам нужно «склеить» несколько значений. Операция, которая позволяет присоединить одно значение к другому, называется конкатенацией и в JavaScript выполняется с помощью знака плюс. Склеивать можно обычные строки, а можно — строки и переменные (или свойства элементов).

console.log('---')
console.log('Раздел 4.2. Строковый и логический тип данных')

let str4 = "Привет" /* переменная создана и находится в памяти браузера. Если этот код написать в консоли и выполнить интером, то консоль напишет undefined. Так и должно быть. Потом если в консоли набрать str4 и нажать интер, то увидем результат 'Привет' */

console.log("длина переменной str4.length:")
console.log(str4.length) /* В консоли вывелось: 6 */

console.log('Длинная строка'.length)  /* Это мы вычислили сразу длину строки. В консоль вывелось 14 - это кол. символов включая пробел */

console.log('Первый символ str4[0]:')
console.log(str4[0]) /* в консоли видим "П". В квадратных скобках ноль - это нулевой индекс */

console.log('Нумерация символов начинается с нуля')

console.log('6-й символ str4[5]:')
console.log(str4[5])

console.log('Если мы хотим получить последний символ, но не знаем сколько символов всего, то пишем так: str4[str4.length-1]:')
console.log(str4[str4.length-1])

// console.log(str4[3,4]) выдаёт в консоль только "е" почему-то, это аналогично str4[4]:

console.log(str4[3,4]) /* в консоли "е" */
console.log(str4[4]) /* в консоли "е" */

console.log(' ')

// Метод slice() (JavaScript Array):
// Метод slice() - позволяет возвратить новый массив, который содержит копии элементов, вырезанных из исходного массива. https://www.basicweb.ru/javascript/js_array_slice.php

console.log("str4.slice(1):")
console.log(str4.slice(1)) /* в консоли видим "ривет". Слайс с индексом 1 выдаёт все, начиная с индекса 1 и до самомого конца */

console.log("str4.slice(1,3):")
console.log(str4.slice(1,3)) /* В консоли получаем "ри" - это символы с индексом 1,2 - с первого ДО 3-го, причем 3-ий индекс не включается в выборку */

console.log(' ')

// Метод toLowerCase. https://code.mu/ru/javascript/manual/string/toLowerCase/
// Метод toLowerCase преобразует символы строки в нижний регистр (из больших букв делает маленькие). При этом мы получаем новую строку, а исходная строка остается неизменной.

console.log("str5='ЗАГЛАВНЫЕ_БУКВЫ'")
let str5='ЗАГЛАВНЫЕ_БУКВЫ'

console.log("str5.toLowerCase():")
console.log(str5.toLowerCase()) /* Получили в консоли "заглавные_буквы". Если в конце метода не написать пустые скобки (), то он не выполняется */

console.log(' ')

// Метод toUpperCase https://code.mu/ru/javascript/manual/string/toUpperCase/
// Метод toUpperCase производит преобразование строки в верхний регистр (из маленьких букв делает большие). При этом возвращается новая строка, а исходная строка не меняется.

console.log("str6='строчные_буквы'")
let str6='строчные_буквы'

console.log("str6.toUpperCase():")
console.log(str6.toUpperCase()) 

console.log(' ')

// Получив неправильную строку от пользователя с неправильным количеством пробелов и неправильные заглавные буквы, нам нужно её исправить с помощью изученных методов:

console.log("let str7='  непРаВилЬная  СТРока  '")
let str7='  непРаВилЬная        СТРока  '

console.log("str7.toLowerCase() (примечание, при этом str7 остаётся неизменной)")
console.log(str7.toLowerCase())

// Метод trim
// Метод trim удаляет пробелы по краям строки. Чаще всего это нужно при вводе пользователем каких-либо значений: он может случайно налепить лишних пробелов - и наша задача очистить введенный текст от них.

console.log("let str8=str7.toLowerCase().trim()")
let str8=str7.toLowerCase().trim()
console.log(str8) 
// в консоли получили "неправильная        строка" с кучей пробелов в середине (лишние пробелы убираются методом trim() только по краям)

console.log('let str9=str8[0].toUpperCase()+str8.slice(1)')
let str9=str8[0].toUpperCase()+str8.slice(1)
console.log(str9) /* Получили "Неправильная        строка" */

console.log(' ')

// Удалим лишние пробелы в середине строки
// https://qna.habr.com/q/597048

let str10=str9.replace(/ +/g, ' ').trim()
console.log("let str10=str9.replace(/ +/g, ' ').trim()")
console.log(str10)
// Результат в консоли: "Неправильная строка" . Здесь используются регулярные выражения

// https://code.mu/ru/javascript/manual/string/replace/
// Метод replace осуществляет поиск и замену частей строки. Первым параметром принимается подстрока, которую заменяем, а вторым - подстрока, на которую заменяем.
// https://www.techiedelight.com/ru/remove-whitespaces-string-javascript/

console.log("\n     Логические типы данных и операции") /* \n - это перенос на новую строку в Java Script */

console.log("\nЛогическое И, символы &&")

// Символ &, или амперсанд, — это союз «и». Примерно в начале XIX века он был 27-й буквой английского алфавита. Рассказывая алфавит у доски, школьники говорили»…X, Y, Z, and and». Неудобно и непонятно. Тогда эту закорючку и начали называть and per se and — то есть «непосредственно and». Постепенно and per se and превратилось в ampersand (амперсанд) — современное название.

let str11=true && true
console.log("\nlet str11=true && true") /* && - это как бы блок логического И, работающий по принципу 2 из двух, на который с двух сторон приходит 2 сигнала и на выходе получаем труе или фалсе в переменной */
console.log(str11) /* результат: true */

let str12=true && false
console.log("\nlet str12=true && false")
console.log(str12) /* результат: false */

let str13=false && false
console.log("\nlet str13=false && false")
console.log(str13) /* результат: false */

console.log("\nЛогическое ИЛИ, символы ||")

// Вертика́льная черта́ — символ ASCII, имеющий код 0x7C (hex), 124 (dec). Этот символ пользователи UNIX называют «пайп», от англ. pipeline — конвейер. В первых, ещё советских, изданиях книг В. Э. Фигурнова название «pipe» было переведено как «символ трубопровода». В C-подобных языках символ "|" служит для операции побитового «или» (дизъюнкция), а два таких символа, написанных слитно ("||"), используются в операции логического «или».

let str14=true || false
console.log("\nlet str14=true || false")
console.log(str14) /* получили true */

let str15=false || false
console.log("\nlet str15=false || false")
console.log(str15) /* получили false */

// Восклица́тельный знак (!) exclamation mark (англ.) В языке Си и некоторых других языках программирования символом «!» обозначается операция логического отрицания, а сочетанием «!=» — операция сравнения «не равно». В некоторых языках используется также «!==» и другие составные знаки. В некоторых диалектах Бейсика восклицательный знак, поставленный сразу после имени переменной, означает, что эта переменная — с плавающей запятой и обычной точности.

let str16=!true /* посклицательный знак означает отрицание НЕ */
console.log("\nlet str16=!true")
console.log(str16) /* получили false */

let str17=7>5
console.log("\nlet str17=7>5")
console.log(str17) /* получили true */

let str18=7>7
console.log("\nlet str18=7>7")
console.log(str18) /* получили false */

let str19=7>=7
console.log("\nlet str19=7>=7")
console.log(str19) /* получили true */

let str20=7==7 /* Сравнение чисел. Если набрать одно равно, то выдаст ошибку синтаксиса */
console.log("\nlet str20=7==7")
console.log(str20) /* получили true */

let str21=7=='7' /* сравнили число с числом, которое в виде типа данных "строка" */
console.log("\nlet str21=7=='7'")
console.log(str21) /* получили true, Java Script произвёл приведение данных */

let str22=7==='7' /* с помощью тройного равно (строгое равно) сравнили число с числом, которое в виде типа данных "строка" */
console.log("\nlet str22=7==='7'")
console.log(str22) /* получили false потому что тройное равно сравнивает не только числа, но и типы данных */

// Разница в том, что тройное равенство является оператором строгого равенства (strict - строгий). Потому что при этом не выполняется приведение типов. Оператор строго равенства возвращает true только, когда оба значения идентичны/точно такие же.

let str23=7!='7' /* != - не равно, при этом == заменяется на !=, то есть одна равношка меняется на ! */
console.log("\nlet str23=7!='7'")
console.log(str23) /* результат: false потому что 7 равно 7 (сделано приведение типов) */

let str24=7!=='7' /* !== - СТРОГО не равно */
console.log("\nlet str24=7!=='7'")
console.log(str24) /* результат: true потому что 7 равно 7, но типы данных: слева - число, справа - строка */

let str25=5!='7' /* != - не равно */
console.log("\nlet str25=5!='7'")
console.log(str25) /* результат: true */

// Типы undefined и null - это 2 дополнительных типа данных
// undefined означает что переменная не определена
// null - пустая переменная

let g 
console.log("\nlet g")
console.log(g) /* в консоли получили undefined потому что не задали переменную, но проинициализировали её и поэтому ошибки нет в консоли. Если попробовать вывести в консоль вообще неизвестную переменную f, то появится надпись ReferenceError */

let h=null /* сделали переменную как бы пустой */
console.log("\nlet h=null")
console.log(h) /* в консоли результат null */

// null - Примитивный тип данных. Состоит из единственного значения null и обозначает отсутствие значения. Значение null используют, когда нужно обозначить намеренное отсутствие значения. В языке существует похожий примитив undefined, он обозначает, что значение ещё не установлено. Их можно легко спутать, потому что оба обозначают отсутствие значения. Разница состоит в том, что null обозначает намеренное отсутствие, а undefined — неявное. https://doka.guide/js/null-primitive/

console.log('\n---')
console.log('\n Раздел 4.3. Шаблонные строки, случайные числа, Округление чисел')

/* console.log('Текст на двух
строках') Получаем ошибку "Строковый литерал без признака конца". */
// При попытке в консоль вывести текст расположенный на 2-х строках с помощью кавычек "" и '', получаем ошибку в VSCode.

console.log(`\n Текст на 2-х
строках`) /* Специальные обратные кавычки позволяют делать текст на несколько строк, находятся на кнопке где тильда, слева над табом */

let v=47
console.log(`\n Обратные специальные кавычки и на 
второй строке переменная v= ${v}
и на 3-ей строке текст`)
// обратные кавычки - единственные кавычки в JavaScript, в которых можно использовать встраивание переменных с помощью символа доллара $ и фигурных скобок

// Ниже сделаем запись на 2 строки с помощью обычных кавычек:
console.log("\n Обычные кавычки, затем ставим n \n и оказываемся на 2-ой строке \n и на 3-ей строке выводим переменную v=" + v + " при этом в коде всё пишется в одну строку, и надо ещё обязательно писать + иначе получаем Error")

let math1=Math.random() /* Math обязательно с большой буквой. с помощью random() мы сгененрируем случайное число от 0 до 1 не включая единицу, при этом нужно обязательно ставить скобки,  возвращаемое при помощи Math.random() может быть 0, но никогда не будет равно 1 */
console.log("\n Рандомное число math1 = " + math1) /* получили в консоли рандомное число, которое при каждом перезапуске страницы меняется */

// Математический максимум:
let math2=Math.max(-5,5,10,40.88,2) /* вычисление максимального числа из ряда чисел, находящихся в скобках, перечисленных через запятую */
console.log("\n Математический максимум math2 = " + math2) /* получили в консоли 40.88 */

// Возведение в степень (метод pow)
let math3=Math.pow(2,5) /* переводе число это то что хотим возводить в степень, второе число - степень, то есть (2,5) это 2 в степени 5 */
console.log("\n Возведение в степень (метод pow). math3=Math.pow(2,5) = " + math3) /* получили в консоли 32 */

// Здесь можно извлечь корень с помощью pow, делаем степень равной 0.5 :
let math4=Math.pow(16,0.5)
console.log("\n корень из 16 методом pow math4=Math.pow(16,0.5) = " + math4) /* получили в консоли 4 */

// Для корнеизвлечения есть специальная функция sqrt. Аббревиатура SQRT — square root (англ.) - переводится как квадратный корень:
let math5=Math.sqrt(64)
console.log("\n Корень из 64 методом sqrt = " + math5) /* получили в консоли 8 */

// Округление дробного числа в меньшую сторону Math.floor(х), где х - дробное число, которое будем округлять:
let math6=Math.floor(3.9)
console.log("\n Округление дробного числа в меньшую сторону 3.9 с помощью Math.floor(3.9) = " + math6) /* получили 3 */

// Округление дробного числа в большую сторону Math.ceil. Ceiling = потолок, ceil - потолочный прилагательное :
let math7=Math.ceil(3.1)
console.log("\n Округление дробного числа в большую сторону 3.1 с помощью Math.ceil(3.1) = " + math7) /* получили 4 */

// Округление дробного числа по стандартным математическим правилам Math.round(x), где x - переменная которую округляем:
let math8=Math.round(3.5)
console.log("\n Округление дробного числа 3.5 с помощью Math.round(3.5) = " + math8) /* получили 4 */
let math9=Math.round(3.4)
console.log("\n Округление дробного числа 3.4 с помощью Math.round(3.4) = " + math9) /* получили 3 */

// Есть метод округления trunc который просто убирает дробную часть, какой бы она не была. truncate - усекать, укоротить:
let math10=Math.trunc(7.444)
console.log("\n Округление дробного числа 7.444 с помощью Math.trunc(7.444) = " + math10) /* получили 7 */

// Округление до фиксированного количества знаков после запятой toFixed(x), где х - количество знаков после запятой:
let math11=9.56561648
let math12=math11.toFixed(3)
console.log("\n Округление дробного числа 9.56561648 с помощью math11.toFixed(3) до 3-х знаков после запятой = " + math12) /* получили 9.566, при этом .5656 округлилось по правилам математики до 0.566 */

// Действие преобразующее строку в число:
let math13="42"
let math14=math13+2
console.log("\n math13='42'+2 = " + math14) /* получили 422 (произошла контагенация) */
let math15=+math13+2
console.log("\n Добавим один + перед строковой переменной. math15=+math13+2 = " + math15) /* получили 44 (контаценации не произошло). Это мы как бы самостоятельно конвертируем строки в числа */

// Встроенная функция для проверки является ли переменная числом isFinite() (конечный, ограниченный, финитный):
math16="300"
console.log("\n Встроенная функция для проверки - является ли переменная числом - isFinite('300') = " + isFinite(math16)) /* получили true */

console.log("\n Встроенная функция для проверки является ли переменная числом isFinite('str78') = " + isFinite("str78")) /* получили false */

function randomInteger(min,max) /* эта функция вычисляет рандомное целое число в пределах минимума и максимума задаваемых пользователем. Обычно эти функции берутся где-нибудь из интернета (https://learn.javascript.ru/task/random-int-min-max) */
{
    let rand = min + Math.random() * (max + 1 - min);
    return Math.floor(rand);
}

console.log("\n Используем лично созданную функцию создания рандомного числа randomInteger(1,5) = " + randomInteger(1,5)) /* получаем случайное целое число, которое меняется при каждой перезагрузке страницы  */
// (max + 1 - min) используется для того, чтобы намеренно прибавить +1 и получить при пределах 1-5 0,98(теоретический выскочивший рандом)*5=4.9 который потом плюсуется с мин = 1, получаем 5.9, и округляем вниз до 5. То есть этот + 1 даёт большую вероятность получить ровно 5, иначе если +1 не написать, то 5 по стандартному решению через random будет выпадать крайне редко. Есть простой метод округления без всяких +1, округление простым round-ом, но тогда там будут проблемы с низкой веротностью получения крайних значений, получится неравномерная характеристика вероятностей.


/* 
Вопрос №1: Как перевести текст на новую строку?
Ответ №1: \n
*/

console.log("\n --- \n 9.4 Массивы")

let arr = [5,2,"Str1", true] /* array (англ.) = массив */
console.log("\n Массив arr: " + arr) /* получили  Массив arr: 5,2,Str1,true */
console.log(arr) /* получили вертикальное раскрывающееся меню с массивом */

console.log("\n Длина массива arr.length = " + arr.length) /* получили 4 */

console.log("\n Выведем элемент 2 массива. arr[2] = " + arr[2]) /* получили Str1 */

console.log("\n Изменим элемент 2 массива. arr[2] = 'Text' ")

arr[2] = "Text" /* Примечание: Не нужно писать let если хотим присвоить новое значение индексу массива. Если написать let то пишет кучу ошибок в стиле "невозможно присвоить объект" */

console.log("\n Выведем элемент 2 массива. arr[2] = " + arr[2]) /* Получили 'Text' */

console.log("\n Массив arr:" + arr) /* Получили массив в строку, без меню */

console.log(arr) /* получили массив в виде меню, и видно что "Str1" поменялось на "Text" */

// Далее добавим в массив значение в индекс 5, при этом этого индекса 5 в массиве нет

arr[5] = 7 /* Написали присвоение индексу 5 массива arr значение 7 */

console.log("\n Написали присвоение индексу 5 массива arr значение 7: arr[5] = 7")

console.log("\n Массив arr:" + arr) /* Получили массив с 7 на индексе 5, а на 4 идексе ничего не было, поэтому там написано ",," */

console.log(arr) /* Получили массив в виде меню, с 7 на индексе 5, а на 4 идексе ничего не было, поэтому там написано "пусто" */

// Матрицы:
console.log("\n Матрицы:")

// Создадим матрицу из 3-х массивов в каждом по 3 элемента
let matrix = [
    [1.1,1.2,1.3],
    [2.1,2.2,2.3],
    [3.1,3.2,3.3]
]

console.log(matrix) /* Получили массив в виде меню, у которого написано "(3) [Array(3), Array(3), Array(3)]" и если раскрыть массив, то видно матрицу по три значения в каждой из 3-х строк */

console.log("\n Матрица = " + matrix) /* если вывести с текстом перед самой матрицей, то видим все числа в строку " Матрица = 1.1,1.2,1.3,2.1,2.2,2.3,3.1,3.2,3.3" */

console.log("Вывели элемент в центре матрицы: matrix[1][1] = " + matrix[1][1]) /* Видим 2.2 */
// То есть мы берем массив с индексом 1 и в нем обращаемся к индексу 1. 
// matrix[индекс массива][индекс элемента в массиве]

// Далее получение элемента массива с помощью .length
console.log("\n Неправильно обратимся к посленему индексу массива arr[arr.length] = " + arr[arr.length]) /* видим в консоли undefined потому что length равен числу от 1 до последнего, а индексы у нас нумеруются с нуля, и получается что мы обратились к индексу на единицу больше чем есть */

console.log("\n Последний индекс arr[arr.length-1] = " + arr[arr.length-1])

// Далее разберем ОЧЕРЕДЬ с методом PUSH и SHIFT

// Метод SHIFT (выбросить первый элемент):

console.log("\n ОЧЕРЕДЬ с PUSH и SHIFT:") 

console.log("\n Изначальный массив arr: " + arr) 

console.log("\n Выбросим первый элемент с помощью конструкции arr.shift()") 

arr.shift() /* Выбрасывание первого элемента и массива. В скобки ничего писать не надо */

console.log("\n Массив после выбрасывания элемента: " + arr) /* Видим, что нет первого элемента, в котором было число 5, и при этом все элементы сдвинулись влево и число 2 стало первым (было вторым) */

// Метод UNSHIFT(добавляемый элемент) - Добавление элемента в начало очереди

console.log("\n Добавим в начало массива новый элемент с помощью конструкции arr.unshift('Первый элемент')") 

arr.unshift("Первый элемент")

console.log("\n Массив после добавления элемента с помощью unshift: \n" + arr)

// Метод PUSH (x) , где x - добавляемый элемент. Добавление элемента в массив в конец очереди)

console.log("\n Изначальный массив arr: " + arr) 

console.log("\n Добавим в конец массива новый элемент с помощью конструкции arr.push('Последний элемент')") 

arr.push("Последний элемент") /* Если такой код набрать в консоли и нажать интер, то появится "4" - это длина нового массива */

console.log("\n Массив после добавления нового элемента (который автоматически добавляется в конец массива): " + arr) /* Первый элемент,2,Text,true,,7,Последний элемент */

// Далее разберем STACK (стопка, кипа бумаг в переводе с англ.) в котором мы помещаем что-то в конец и забираем тоже с конца. Методы Push и POP

console.log("\n STACK, стэк, стопка или кипа бумаг:")

// Метод PUSH (добавление элемента в массив в конец очереди) мы уже знаем

// Метод POP (извлечение последнего элемента)

console.log("\n Изначальный массив arr: " + arr) /* Первый элемент,2,Text,true,,7,Последний элемент */ 

console.log("\n Извлечем из конца массива последний элемент с помощью конструкции arr.pop(). В скобки ничего писать не надо") 

arr.pop() /* Извлечение последнего элемента */

console.log("\n Массив после arr.pop(): " + arr) /* Видим "Массив после arr.pop(): Первый элемент,2,Text,true,,7". Исчез "Последний элемент" */

/* Итого:

1. Очередь
 1.1 PUSH - добавление в конец очереди
 1.2 Shift - убрать из начала очереди
 1.3 Unshift - добавить в начало очереди

 2. СТЭК (Stack)
2.1 PUSH - добавление в конец стопки
2.2 POP - убрать из конца стопки

*/

// Метод concat (конкатенация) для массивов

// Создадим массив №2
let arr2 = [21,22,22]
console.log("\n Новый массив arr2= " + arr2)

// Моздадим массив №3 который будет состоять из массива №1 к которому присоединим массив №2:

let arr3 = arr.concat(arr2) /* сначала пишем массив 1 к которому хотим присоединить, затем метод конкатенации у которого в скобках массив 2 который присоединится к первому */

console.log("\n Написали команду arr3 = arr.concat(arr2)")

console.log("\n Новый массив arr3 = " + arr3) /* видим Первый элемент,2,Text,true,,7,21,22,22 */

// Метод indexOf (вычисление индекса известного нам элемента):
console.log("\n Метод indexOf. Вычисляет индекс определенного элемента в массиве")
console.log("\n arr3.indexOf(22) = " + arr3.indexOf(22)) /* видим 7. При этом там есть ещё один 22 на индексе 8, но показывает только один индекс 7 */

// Если мы знаем что в массиве есть элемент, то мы можем вычислить его индекс с помощью метода indexOf

// Метод join (объединение индексов):

console.log("\n Создадим новый массив arr4 = [41,42,42]")

let arr4 = [41,42,42]

arr4.join() /* Если так написать, то такая запись склеивает все значения массива в новую переменную в памяти как бы, склеивает по умолчанию ставя между элементами запятые, но не изменяет исходный массив, и для того чтобы запомнилось это новое изменение, нужно присвоить какой-то новой переменной это преобразование этим методом. Запись аналогична arr4.join(",") */
console.log("\n Написали комманду arr4.join()")

console.log("\n Выводим массив arr4 и видим, что он не поменялся:")

console.log(arr4)

let arr5 = arr4.join()

console.log("\n Написали комманду: let arr5 = arr4.join()")

console.log("\n Выводим массив arr5 и видим, что он состоит из одного индекса, но элементы склены по умолчанию через запятую")

console.log(arr5)

let arr6 = arr4.join(" / ")

console.log("\n Написали комманду: let arr6 = arr4.join(' / ') и получаем массив из склееных элементов через наклонную черту:")

console.log(arr6)

let arr7 = arr4.join("")

console.log("\n Написали комманду: let arr7 = arr4.join('') и получаем массив из склееных элементов монолитно без разделителей:")

console.log(arr7)

// Универсальный метод splice для массивов, который позволяет добавлять, удалять и заменять любые элементы в массивах:

console.log("\n Метод splice:")

let arr_for_splice = ["Эл1", "Эл2", "Эл3", "Эл4", "Эл5" ]

console.log("\n Выводим массив arr_for_splice: " + arr_for_splice) 
// Получили: Эл1,Эл2,Эл3,Эл4,Эл5

// Далее удалим 1 элемент:

let arr31 = arr_for_splice.splice(1,1) /* удаляем элементы начиная с индекса №1, количество этих элементов = 1 */
// Первый параметр в скобках - это начальный индекс. 
// Второй параметр - это количество удаляемых элементов.
// Третий необязательный параметр - объект который вставится взамен удаленного

console.log("\n let arr31 = arr_for_splice.splice(1,1)") 

console.log("\n Массив arr31 сделавший splice : " + arr31) /* Получили Эл2 потому что после splice мы получаем то что вырезаем */

console.log("\n Выводим массив arr_for_splice: " + arr_for_splice) 
// Получили: Эл1,Эл3,Эл4,Эл5. "Эл2" между Эл1 и Эл3 исчез.  
// То есть метод splice удаляет элемент из оригинального массива изменяя оригинальный массив. А то что он удалил можно отдельно в другую переменную положить

// Далее удалим все элементы начиная с индекса 1: 

let arr32 = arr_for_splice.splice(1)
// Такая запись удалит из массива все элементы начиная с индекса 1 включительно

console.log("let arr32 = arr_for_splice.splice(1)")

console.log("\n Массив arr32 сделавший splice : " + arr32) /* Получили Эл3,Эл4,Эл5 потому что после splice мы получаем то что вырезаем */

console.log("\n Выводим массив arr_for_splice: " + arr_for_splice) 
// Получили: Эл1. Все последующие элементы исчезли

// Далее ничего не удаляя добавим 5 элементов

let arr33 = arr_for_splice.splice(1,0, "Новый элемент 10","Эл11",42,33,34)
// Такая запись означает: начиная с первого индекса включительно удалить 0 элементов, и добавить много элементов далее. То есть мы здесь только добавляем.
// В такой операции не нужно на самом деле let arr33 потому что массив arr33 будет пустым. Эту операцию нужно просто выполнить.   

console.log("\n let arr33 = arr_for_splice.splice(1,0, 'Новый элемент 10','Эл11',42,33,34)")

// console.log(arr33) - Такая запись выводит пустой массив без элементов почему-то

console.log("\n Выводим массив arr_for_splice: " + arr_for_splice) 
// Получили: Эл1,Новый элемент 10,Эл11,42,33,34. То есть к Эл1 добавилась куча элементов

// Далее удалим два индекса №3 и №4 (число 42 и 33) и вставим новый один элемент (число 52)

arr_for_splice.splice(3,2,52)

console.log("\n Далее удалим 2 индекса №3 и №4(число 42, 33) и заменим его на 1 новый (число 52): arr_for_splice.splice(3,2,52)")

console.log("\n Выводим массив arr_for_splice: " + arr_for_splice)
// Получили Эл1,Новый элемент 10,Эл11,52,34 
// Видим что числа 42,33 исчезли, и взамен них появилось одно 52

// Метод splice поддерживает отрицательные значения:

arr_for_splice.splice(-1,0,"Вставка -1") /* -1 отрицательный индекс в самом начале скобок означает что считая с конца на 1 элемент раньше выполнить действие - ничего не делать (второе значение 0) - и затем вставить Элемент. Короткр: вставили перед последним элементом. */

console.log("\n Выводим массив arr_for_splice: " + arr_for_splice)
// Видим: Эл1,Новый элемент 10,Эл11,52,Вставка -1,34
// Между 52 и 34 появился элемент "Вставка -1". Вставили перед последним элементом
// Если индекс -2 написать, то будет операция перед предпоследним индексом.

// Метод slice - возвращает нам какое-то количество элементов массива не портя оригинал

console.log("\n Метод slice:")
let arr_for_slice = ["Эл21", "Эл22", "Эл23", 4, false, 6, 7, 8]

console.log("\n Новый массив arr_for_slice: " + arr_for_slice)

let arr34 = arr_for_slice.slice(0,3) /* Элементы с индекса 0 до индекса 3 не включительно вернуть в новый массив не повреждая оригинал. Будут 3 элемента: 0,1,2 */

console.log("\n let arr34 = arr_for_slice.slice(0,3)")

console.log("\n массив arr_for_slice не изменился :" + arr_for_slice)

console.log("\n массив arr34:" + arr34)

// Получили массив arr34:Эл21,Эл22,Эл23

let arr35 = arr_for_slice.slice(4) /* Вернутся элементы начиная с индекса и до конца*/

console.log("\n let arr35 = arr_for_slice.slice(4)")

console.log("\n массив arr35:" + arr35)

// Получили: массив arr35:false,6,7,8

let arr36 = arr_for_slice.slice(-2) /* получить массив из предпоследнего элемента и до конца, или коротко говоря последние 2 элемента массива */

console.log("\n let arr36 = arr_for_slice.slice(-2)")

console.log("\n массив arr36:" + arr36)
// Получили: массив arr36:7,8


let arr37 = arr_for_slice.slice(-4,-1) /* скопировать вырезку от 4-го элемента с конца до последнего не включая последний */

console.log("\n let arr37 = arr_for_slice.slice(-4,-1)")

console.log("\n массив arr37:" + arr37)
// Получили:  массив arr37:false,6,7


// --- Метод includes проверяет есть ли какой-то элемент в нашем массиве. Результат булевый ---

console.log("\n Метод includes:")

let arr_for_inclides = ["Эл1", "Эл2", "Эл3", "Эл4", "Эл5", "Эл6"]

console.log("\n Новый массив arr_for_inclides: " + arr_for_inclides)

let var_includes1 = arr_for_inclides.includes("Эл4") /*  */

console.log("\n let var_includes1 = arr_for_inclides.includes('Эл4')")

console.log("\n var_includes1 = " + var_includes1)
// Плучили true


let var_includes2 = arr_for_inclides.includes("эл4")

console.log("\n let var_includes2 = arr_for_inclides.includes('эл4')")

console.log("\n var_includes2 = " + var_includes2)
// Получили false потому что тут важен регистр. "эл4" и "Эл4" это разные элементы


// --- Метод reverse() вовращает нам массив с элементами в обратном порядке: ---

console.log("\n Метод reverse():")

let arr_for_reverse = ["Эл31", "Эл32", "Эл33", 4, false, 6, 7, 8]

console.log("let arr_for_reverse = " + arr_for_reverse)

let arr40=arr_for_reverse.reverse() /* применили метод переворачивания */

console.log("arr40=arr_for_reverse.reverse() = " + arr40)
// Получили 8,7,6,false,4,Эл33,Эл32,Эл31 . Массив перевернулся

console.log("оригинальный массив arr_for_reverse перевернулся = " + arr_for_reverse)
// Получили 8,7,6,false,4,Эл33,Эл32,Эл31. То есть оригинал тоже перевернулся

arr_for_reverse.reverse() /* применили метод переворачивания ещё раз чтоб вернуть всё на место*/

console.log("arr_for_reverse.reverse() - переворачиваем обратно")

console.log("оригинальный массив arr_for_reverse вернулся в исходное положение = " + arr_for_reverse)

// --- Метод split. Расщепляет монолитную строку на массив из отдельных элементов. 

let str_for_split = "Эл41, Эл42, Эл43, Эл44, Эл45" /* строка монолитная для расщепления на массив */

let arr_after_split1 = str_for_split.split() /* Если так написать и ничего не указать в скобках, то получим массив с одним единственным индексом 0 и длиной 1 */

console.log("let arr_after_split1 = str_for_split.split() - НЕправильный код")

console.log(arr_after_split1) /* получили массив со строкой в виде единственного индекса 0 ['Эл41, Эл42, Эл43, Эл44, Эл45']*/

// Чтобы разделить на отдельные элементы, нужно в скобках указать используемый разделитель, в нашем случае это "запятая пробел" ", " :

let arr_after_split2 = str_for_split.split(", ")

console.log('let arr_after_split2 = str_for_split.split(", ") - Правильный код')

console.log("\n Массив после разделения: " + arr_after_split2)
console.log(arr_after_split2)
// Получили: (5) ['Эл41', 'Эл42', 'Эл43', 'Эл44', 'Эл45'] - массив с отдельными 5 элементами

// Далее сделаем то же самое для строки у которой к вачестве разделителей выстпает ТИРЕ:
console.log("\n Далее сделаем то же самое для строки у которой к вачестве разделителей выстпает ТИРЕ:")

let str_for_split2 = "Эл41-Эл42-Эл43-Эл44-Эл45" /* строка с ТИРЕ в качестве разделителей */

console.log('\n let str_for_split2 = "Эл41-Эл42-Эл43-Эл44-Эл45"')

let arr_after_split3 = str_for_split2.split("-")

console.log('\n let arr_after_split3 = str_for_split2.split("-")')

console.log(arr_after_split3)
// Получили: (5) ['Эл41', 'Эл42', 'Эл43', 'Эл44', 'Эл45'] - массив с отдельными 5 элементами


// С помощью split можно разделить слово на массив состоящий из отдельных букв:
console.log("Разделим одно слово на массив состоящий из отдельных букв")

let str_for_split3 = "Разделить"

console.log('let str_for_split3 = "Разделить"')

let arr_after_split4 = str_for_split3.split("") /* d кавычках ничего не указываем, но кавычки должны быть */

console.log('let arr_after_split4 = str_for_split3.split("")')

console.log(arr_after_split4)
// Получили: (9) ['Р', 'а', 'з', 'д', 'е', 'л', 'и', 'т', 'ь']

// Шаг 3. Проверочный вопрос.
// Сопоставьте значения из двух списков
// Извлечь последний элемент -> POP
// Извлечь первый элемент -> Shift
// Добавить элемент в конец -> PUSH

// --- 9.5 Объекты ---
console.log("\n --- 9.5 Объекты ---")

console.log("\n Создадим объект:")

let obj = {
    "color": "Tomato", /* {"Ключ": значениие} это ключ №1*/
    "numbers": [888, 777], /* ключ №2 */
    "checked": true /* ключ №3 */
}
/* Ключи - это строковые переменные. В качестые значений может быть что угодно: строка, число, булева логика, функция, массив, или даже другой объект */

console.log(obj)
// Получили {color: 'Tomato', numbers: Array(2), checked: true}

console.log('\n Выведем в консоль не весь объект, а только один из ключей объекта: ')

console.log('\n obj["color"]: ') /* Это похоже на вызов из массива индекса с помощью квадратных скобок [], только здесь указываем не числовой индекс, а в кадртаных скобках ключ заключенный в кавычки */

console.log(obj["color"]) /* Вызвали с помощью квадратных скобок и ключа из объекта цвет. Получили: Tomato */

console.log('\n obj.color: ')
console.log(obj.color) /* Вызвали с помощью точки и ключа из объекта цвет. Получили то же самое: Tomato */

console.log('\n obj.numbers[1]: ')
console.log(obj.numbers[1]) /* Вызвали с помощью точки из объекта массив чисел и из него число индексом 1. Получили: 777 */

console.log('\n obj["numbers"][1]: ')
console.log(obj["numbers"][1]) /* Вызвали с помощью квадратных скобок из объекта массив чисел и из него число индексом 1. Получили то же самое: 777 */

// Чтобы узнать какие существуют ключи у объекта, существует следующая конструкция:

console.log('\n Object.keys(obj): ')

console.log(Object.keys(obj)) /* то есть пишем Object.keys и в скобках имя нашего объекта. При этом Object пишется с большой буквы */
// Получили для нашего объекта массив в виде ключей: (3) ['color', 'numbers', 'checked']. Только в них не видно что внутри ключей имеется, поэтому нагляднее и легче вывести весь объект целиком

// Добавим в объект новый ключ со значением, которого у нас раньше не было:

console.log('\n Добавим в объект новый ключ со значением, которого у нас раньше не было:')

console.log('\n obj["name"] = "Ivan"')

obj["name"] = "Ivan" /* присвоили новый ключ и значение, причем, в отличии от массивов, тут не нужно соблюдать числовую последовательность индексов. let тоже не требуется  */

console.log(obj) 
// Получили раскрывающийся объект: {color: 'Tomato', numbers: Array(2), checked: true, name: 'Ivan'}
// Что примечательно, они выводятся не в том порядке в котором мы их вводили, а в неупорядоченном непонятно как

// Массив с объектами без названий:

console.log('\n Массив с объектами без названий:') 

let arr_of_three_obj = [
    {
        "color": "Tomato1",
        "numbers": [888, 777],
        "checked": true
    },
    {
        "color": "Tomato2",
        "numbers": [888, 777],
        "checked": false
    },
    {
        "color": "Tomato3",
        "numbers": [888, 12],
        "checked": false
    }
]

console.log(
    `let arr_of_three_obj = [
        {
            "color": "Tomato1",
            "numbers": [888, 777],
            "checked": true
        },
        {
            "color": "Tomato2",
            "numbers": [888, 777],
            "checked": false
        },
        {
            "color": "Tomato3",
            "numbers": [888, 12],
            "checked": false
        }
    ]
    `
)

console.log(arr_of_three_obj)
// Получили раскрывающийся массив: (3) [{…}, {…}, {…}]

console.log('\n console.log(arr_of_three_obj[0]["color"])')

console.log(arr_of_three_obj[0]["color"]) /* Получили: Tomato1 */

console.log(arr_of_three_obj[2]["numbers"][1]) /* Получили: 12 */

/* Вопрос: 
Заполните пропуски
Ответ: Объект на JavaScript состоит из пары: ключ и значение */

// --- 9.6. Диалоговые окна, Тернарный оператор, Переключатель Switch ---

console.log("\n --- 9.6. Диалоговые окна, Тернарный оператор, Переключатель Switch ---")

console.log('\n Функция alert (англ. тревога, оповещение):')

/* alert("Текстовая строка") */ /* получаем всплывающее маленькое окно в котором написано "Уведомление от сайта 127.0.0.1" "Текстовая строка" и кнопочка "Закрыть" внизу */

// При этом на странице идет постоянно как бы загрузка. И это означает что пока мы не нажмем "Закрыть", весь код набранный после alert, не будет выполняться. После того как нажмем "Закрыть" окно исчезает и выполняется код ява-скрипта дальше.

console.log('\n Функция prompt (англ. запрос):')

/* prompt("Введите ваш возраст") */ /* от англ. запрашивать, запрос, побуждать */
// Получили: Второе всплывающее окно в котором написано "Введите ващ возраст" и ниже поле для ввода текста с мигающим курсором, и ниже 2 кнопки "Продолжить" и "Отмена". После введения возраста и нажатия любой кнопи "продолжить" или "Отмена" окно исчезает, при этом введеннные значения никуда не записываются и не запоминаются. Чтобы они запомнились, нужно использовать присвоение переменной, о чём далее.

/* let age = prompt("Введите ваш возраст") */ /* Вылетело первое всплывающее окно с полем ввода текста, в которое вводим 39 и нажимаем внизу кнопку "Продолжить" */

/* alert(`Мой возраст = ${age}`) */ /* Вылетело 2-ое всплывающее окно с надписью "Мой возраст = 39". Если же при вводе возраста нажать "Отмена", то получим "Мой возраст = null", что означает что переменная пустая. Если в поле возраста ввести апр, то выведется "Мой возраст = апр" */

// Условия:

// Зачем выводить null если пользователь ничего не ввел? Для того чтобы этого не было нужно использовать условие if  

/* if (age != null){
    alert(`Мой возраст = ${age}`)
}*/ 
// В круглых скобках написано условие что возраст не должен быть равен ничему
// В фигурных скобках пишем что должно выполниться если условие истина
// В итоге получилось: если пользователь ввел что-то в запросе промпт, то появляется второе окно алерт, где написан текст + возраст
// тут можно еще добавить необязательное условие else

/* if (age != null){
    alert(`Мой возраст = ${age}`)
} else {
    alert(`Вы нажали Отмена`) 
} */
// алерт выполнится только если age=null, то есть только если пользователь нажал Отмена
// Но остается еще загвоздка заключающаяся в том, что если пользователь ничего не ввел и нажал "Продолжить", то это не null, это - как бы пробел - и мы получаем окно алерт с надписью "Мой возраст =  "

console.log('\n Функция confirm (англ. подтвердить):')

// Всплывающее окно confirm работает так, что появляется всплывающее окно, в котором есть какой-то вопрос, и есть только две кнопки "Да" и "Нет". 

/* if (confirm("Удалить ваш аккаунт?")) 
{
    alert("Аккаунт удалён") /* Это выполнится если пользователь нажмет "Да" 
} 
else {
    alert("Отменено") /* Выполняется при нажатии кнопки "Нет" 
} */
// Если else не написать, то при нажатии "Нет" ничего не происходит - окно всплывающее исчезает и всё.
 
console.log('\n Тернарный оператор - аналог условия if :')

// confirm("Удалить ваш аккаунт?") ? alert("Аккаунт удалён") : alert("Отменено")
// После вопроса (?) указываем код, который будет выполнен в случае если условие будет ИСТИНО, а потом двоеточие (:) , после чего действие в случае ЛОЖЬ.

// В итоге длинный код if с else на 8 строк записан очень коротко в виде одной строки

// Здесь может быть только одна строка. И применяется это только для таких коротких вариантов записи - где выполняется только одно действие для ИСТИНЫ и одно действие для ЛЖИ. Можно в скобках указать несколько действий, но не рекомендуется этого делать. Когда более одного действия - рекомендуется использовать if с фигурными скобками.

// --- Составные условные конструкции:
console.log("\n --- Составные условные конструкции:")

// let age = prompt("Введите ваш возраст")

// Код на основе стандартных if - else if:
// if (age < 18){
//     alert("Мой возраст меньше 18") /* получили это окошко когда ввели 17 */
// } else if (age > 18) {
//     alert("Мне больше 18")  /* получили это окошко когда ввели 20 */
// } else if (age == 18) { /* else if (age == 18) -> else {} получим то же самый результат */
//     alert("Мне 18")  /* получили это окошко когда ввели 18 */
// }

// Функция Switch (англ. переключатель) - аналог if-else. Применяется когда много условий, в нем они будут нагляднее:

// let age = prompt("Введите ваш возраст")
// switch(true) { /* true - это то с чем мы сравниваем дальнейшие условия */
//     case age > 18 : 
//         alert("Мне больше 18")
//         break /* с помощью break мы выходим из switch и это нужно чтобы не выполнялся дальнейший код в свиче */
//     case age < 18 && age > 0: /* проверяются 2 условия через логику И. Если этого не написать, то при вводе -20 получим "Мой возраст меньше 18" */
//         alert("Мой возраст меньше 18")
//         break
//     case age == 18:
//         alert("Мой возраст 18 лет")
//         break
//     default : /* это аналог else, который срабатывает когда не было выполнено никаких действий до него */
//         alert("Неправильный возраст") /* Появляется при числах <=0 и при кнопке Отмена */
// }
// В результате кода по количеству строк получилось не меньше чем в стандартном if-else

// Вопрос:
// Сопоставьте
// Окно для ввода = prompt
// Окно с подтверждением и отменой = confirm
// Окно с текстом = alert

// --- 9.7 Циклы + практика ---
console.log("--- 9.7 Циклы + практика ---")

// --- Цикл While:
console.log("--- Цикл While:")

let count = 0

while (count < 10) {
    console.log(count) /* получили в консоли 5 строк с цифрами от 0 до 4 */
    if (count == 4) {break} /* Обязательно два равно, если одно то цикл выдаёт 0 в консоль и дальше не работает. Можно еще 3 равно для полного сравнения включая число и тип. Break останавливает цикл while */
    count++ /* прибавляем к счетчику единицу */
    // Если прибавление не написать, то бесконечно выводятся цифры в консоль влоть до миллионов, это не цифры нашего счетчика, это счетчик количества выполненных действий браузером, выводится ноль 500 000 раз, и процессор загружается почти на 100% и браузер тоже виснет, снятие задачи в диспетчере надо выполнять. Это потому что count всегда остается 0 и не изменяется, и выполняется цикл вывода одного и того же числа в консоль бесконечно
}

console.log(`count = ${count}`) /* Получили 4, значит после сработавшего break не успело выполниться count++ */

console.log("--- Цикл do while:")

console.log("--- Цикл №1:")
let count2 = 10
do {
    console.log(count2) /* получили в консоли 1 строку с цифрой 10 */
    count2++ /* в конце count2 становится = 11, но в консоль оно не выводится потому что условие while сработает на останов */
} while (count2 <7 ) /* первоначальное условие уже изначально завершает цикл потому что 10>7 и получаем false */

console.log(`count2 = ${count2}`) // Получили 11. 

// То есть этот цикл иногда бывает необходим - когда сначала надо выполнить тело 1 раз, а потом уже сделать проверку условия, и если условие true то выполнить 2-ой раз, а если false, то закончить цикл. Стандартный цикл while сначала проверяет, и может ни разу не выполнить тело. 

console.log("--- Цикл №2:")
let count3 = 20
do {
    console.log(count3) /* получили в консоли 3 строки: 20, 19, 18 */
    count3-- /* count3-- при каждом цикле уменьшается на 1. В конце count3 становится = 17, но мы в консоль оно не выводится потому что условие while сработает на останов */
} while (count3 >17 )

console.log(`count3 = ${count3}`) /* получили 17, значит тело выполнилось, сминусовало переменную count3, потом проверка с результатом false, и цикл обрывается */

console.log("--- Цикл for:")
// Это самый распространенный цикл. Если нам нужно выполнить код например 5 раз, то используем его.

console.log("--- Цикл №1:")
for (let i=1; i<=5; i++) 
/* сначала присваиваем переменной начальное значение и не забываем let; затем условие выполнения цикла "выполнять до тех пор пока..."; изменение переменной при каждом цикле */
{
    console.log(i) /* получили в консоли 1, 2, 3, 4, 5 */
}

// console.log(`i = ${i}`) результат "i is not defined" то есть i в цикле for используется временно и только во время цикла, и потом удаляется из памяти

console.log("--- Цикл №2:")
for (let i=20; i>=14; i-=2) {
    console.log(i)
}
// С 20 до 14 включительно выводим в консоль i и при каждом цикле уменьшаем на 2
// Получили: 20, 18, 16, 14.

console.log("--- Цикл №3. Применение for для работы с массивом:")

let arr_for_circleFOR = [5, 7, 9, 1, 0]

console.log(`arr_for_circleFOR = ${arr_for_circleFOR}`)

for (let i=0; i<arr_for_circleFOR.length; i++) {
    console.log(arr_for_circleFOR[i]*=2) /* каждый элемент умножается на 2, причем изменяется оригинальный массив. Получили 5 строк по 1 числу в каждом, умноженным на 2 */
}
console.log(`arr_for_circleFOR = ${arr_for_circleFOR}`)
// Получили: 10,14,18,2,0.
// В итоге мы перебрали массив по элементам, где с каждым элементом провели математическую операцию изменив оригинальный массив

console.log("--- Цикл for of для массивов:")

console.log("--- Цикл №1. Простой вывод элементов массива")
// Этот цикл - специальная более краткая версия цикла for для перебора элементов без присваивания значений и вычислений последнего элемента

for (let item of arr_for_circleFOR) {
    console.log(item) // Получили: 10,14,18,2,0
    console.log(item*2) // Получили: 20,28,36,4,0
}
console.log(`arr_for_circleFOR = ${arr_for_circleFOR}`)
// Получили 10,14,18,2,0. То есть такое выражение только выводит элементы, но не изменяет их в оригинальном массиве 
// let item - это как бы присвоение к любой временной переменной с любым названием значений в массиве методом перебора. Тут можно написать вместо item любое название, например i, index и так далее 

// console.log("--- Цикл №2. Умножене элементов массива на 2")
// for (let item of arr_for_circleFOR) {
//     // console.log(item*=2) // такая запись умножит на 2, введет в консоль, но не изменит оригинал
//     // item*=2 и такая - тоже не изменит
//     // console.log(arr_for_circleFOR[item]*=2) // а так вообще сплошные ошибки NaN потому что item это сам элемент, а не индекс, и получается что например если item получился 98, то мы пытаемся вывести в консоль arr_for_circleFOR[98], то есть элемент с индексом 98 (которого в данном массиве нет). 
// }
// console.log(`arr_for_circleFOR = ${arr_for_circleFOR}`)

// Цикл for of применяется не только к масивам, особенно хорошо он работает с html-элементами.

console.log("--- Цикл for in для объектов:")
// У объектов используются ключи, а не индексы. Поэтому для объектов был создан специально этот цикл

let obj2 = {
    "name": "Евген", 
    "age": 39,
    "number": 89234076582,
}
// в конце это - висячая запятая, облегчает добавление/удаление/сортировку кллючей

for (let key in obj2) {
    console.log(key) // выводим название ключа
    console.log(obj2[key]) // выводим значение ключа 
}
// Получили 6 строк:  name, Евген, age, 39, number, 89234076582 

for (let key in obj2) {
    console.log(`Ключ ${key}, значение ${obj2[key]}`)
}
// Получили 3 строки: 
// Ключ name, значение Евген, 
// Ключ age, значение 39
// Ключ number, значение 89234076582 

// этот цикл не рекомендуется применять к обычным массивам потому что он может вернуть и те ключи, которые мы не хотим видеть (это ключ у массива length и _proto_). 

// --- Дополнительная работа с массивами: ---

// Метод forEach. Этот новый метод недавно появился, с помощью него можно проходить по элементам массива и что-то с ними делать
console.log("--- Метод forEach для массивов:")

let arr_for_addition = [5, 7, 9, 1, 0]
arr_for_addition.forEach(function(item, index, array){ // Анонимная функция с 3 параметрами: значение, индекс, массив. Названия переменных - любое, важен их порядок объявления в функции, и оспользуются они временно, поэтому названия могут совпадать с используемыми вроде как.
    console.log(`Элемент: ${item}
    Удвоенный элемент: ${item*2}
    Индекс: ${index}
    Массив: ${array}`)
})
// Получили:

// Элемент: 5
// Удвоенный элемент: 10
// Индекс: 0
// Массив: 5,7,9,1,0

// Элемент: 7
// Удвоенный элемент: 14
// Индекс: 1
// Массив: 5,7,9,1,0

// Элемент: 9
// Удвоенный элемент: 18
// Индекс: 2
// Массив: 5,7,9,1,0

// Элемент: 1
// Удвоенный элемент: 2
// Индекс: 3
// Массив: 5,7,9,1,0

// Элемент: 0
// Удвоенный элемент: 0
// Индекс: 4
// Массив: 5,7,9,1,0

// То есть на каждой итерации в консоль мы получаем Элемент, удвоенный элемент, индекс, и весь массив. Весь массив постоянно повторяется и если он нам не нужен то его можно исключить.

// --- Метод find для массива и объектов:
console.log("--- Метод find для массива и объектов:")

let people = [
    {id: 1, name: "Ivan"},   /* индекс 0 */
    {id: 2, name: "Masha"},  /* индекс 1 */
    {id: 3, name: "Alex"},   /* индекс 2 */
    {id: 4, name: "Kate"}    /* индекс 3 */
] 
// ключ можно не заключать в кавычки если в нём одно слово
// такое строение объектов всплывает в подсказке когда набираешь find

let item_find = people.find(function(item) /* в анонимной функции используем только item */
{
    if(item.id==2) return item /* функция возвращает элемент */
})
console.log(item_find) // получили безымянный объект {id = 2, name: 'Masha'}
// item.id это мы сначала обращаемся к элементу массива, и так как элементы у нас это объекты, то ставим точку и пишем id что является ключом, получается "объект.ключ" через точку.

// --- Метод findIndex для массива:
console.log("--- Метод findIndex:")

let find_index = people.findIndex(function(item) /* в анонимной функции используем только item */
{
    if(item.id==2) return item /* теперь функция возвращает найденный элемент, но в переменной получаем индекс */
})
console.log(find_index)
// Получили "1"

// --- Метод filter для массива:
console.log("--- Метод filter:")
console.log("--- if(item.id==2):")

let filter1 = people.filter(function(item) {
    if(item.id==2) return item /* теперь функция возвращает найденный элемент, но в переменной получаем один или несколько массивов */
})
console.log(filter1)
// Получили раскрывающийся массив с одним объектом с индексом 0 (индекс в пределах нового массива, а не в пределах старого массива):
// 0:{id: 2, name: 'Masha'}

console.log("--- if(item.id<3):")

let filter2 = people.filter(function(item) {
    if(item.id<3) return item /* теперь функция возвращает найденные элементы, и в переменной получаем несколько массивов */
})
console.log(filter2)
// Получили раскрывающийся массив с 2-мя объектами с индексом 0 и 1:
// 0: {id: 1, name: 'Ivan'}
// 1: {id: 2, name: 'Masha'}

// С помощью метода find нельзя получить несколько элементов удовлетворяющим условиям, а с помощью filter - можно.

// --- Метод map для массива:

console.log("\n --- Метод map:") /* Это от англ. слова карта, как бы составляем карту */

let arr_for_map = [5, 7, 9, 1, 0]

let arr_new = arr_for_map.map(function(item, index)
{ return item*3 })
// В каждый элемент нового массива будет помещен оригинальный элемент умноженный на 3 

// В VSCode неиспользуемый элемент в функции помечается серым цветом, его можно удалить вручную

console.log(arr_new)
// Получили: (5) [15, 21, 27, 3, 0]
// Мы как бы составили новый массив методом создания карты на основе карты оригинального массива. При этом оригинальный массив не тронут


console.log("\n --- Решение задач для закрепления:")

console.log("\n --- Задача №1: Создать массив состоящий из четных чисел от 0 до 20")

let arr_task1 = [] // создали пустой массив, ошибок нет, ошибки будут только если назвать его уже используемым именем

for (let i=0; i<20; i+=2) 
/* используем название переменной i которая уже была использованна, она используется временно и поэтому её можно повтороно много раз писать */
{
    arr_task1.push(i)
}
console.log(arr_task1)
// Получили раскрывающийся массив: (10) [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

console.log("\n --- Задача №2: Создать массив состоящий из убывающих чисел от 30 до 0 и должны делиться на 3 без остатка")

let arr_task2_1 = []

for (i=30; i>0; i-=3) {
    arr_task2_1.push(i)
}
console.log(arr_task2_1)
// Получили раскрывающийся массив: (10) [30, 27, 24, 21, 18, 15, 12, 9, 6, 3]
// Это мы решили с учетом математики заранее зная что вот такие числа делятся.

// Решим эту же задачу с помощью проверки условия деления на 3 
let arr_task2_2 = []

for (i=30; i>0; i--) { // перебираем каждое число с шагом 1 в сторону уменьшения
    if (i%3==0) { // если остаток от деления i на 3 равен нулю
        arr_task2_2.push(i)
    }
}
console.log(arr_task2_2)
// Получили (10) [30, 27, 24, 21, 18, 15, 12, 9, 6, 3]

console.log("\n --- Задача №3: Создать массив состоящий из элементов в диапазоне 0-10, каждый из которых равен квадрату его индекса")

let arr_task3 = []

for (let i=0; i<10; i++) {
    arr_task3.push(Math.pow(i,2)) // Математическая функция Math.pow(число, степень). Число = переменная i, степень 2. Можно было написать i*i по самому простому методу.
}
console.log(arr_task3)
// Получили: (10) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

console.log("\n --- Задача №4: Найти количество четных элементов в массиве")

let arr_task4 = [7,4,2,1,0,6,2,6,2,15,4,16,20]
console.log(arr_task4)

// Метод 1, через for of:

let even = 0 // even - англ. четный
for (let item of arr_task4) {
    if (item%2==0) {even++}
}
console.log(`Количество четных элементов = ${even}`)
// Получили: 10


let even2 = 0
for (i=0; i<arr_task4.length; i++) {
    if (arr_task4[i]%2==0) {even2++}
}
console.log(`Количество четных элементов = ${even2}`)
// Получили: 10

// Контрольные вопросы:

// В соответствии с синтаксисом укажите правильный тип цикла.

// ? (let k in obj) { }
// ? (i>10) { }
// ? (let i=0; i<10; i++) { }

// Ответ:
// for (let k in obj) { }
// while (i>10) { }
// for (let i=0; i<10; i++) { }

// --- 9.8 Функции + практика

function printText () {
    console.log(`Hello`)
}
// printText - это название функции
// В консоли мы ничего не видем потому что сама по себе функция ничего не делает пока мы её не вызовем.

printText() // Вызвали функцию, получили в консоли "Hello"
// В данном случае в скобках ничего нет, но там могут быть разные атрибуты

function printText2 (name, age) { // 2 параметра (name, age) в круглых скобках? существуют временно только в пределах функции, могут совпадать с ранее определенными
    console.log("Hello My name is " + name + ", Age: " + age)
}
printText2()
// Получили: Hello My name isundefined, Age: undefined
// Это потому что эти переменные не существуют, чтобы они были нужно при вызове функции в скобках передать значения.

printText2("Евген", 39) 
// Здесь "Евген" идет как первый параметр функции "name", 39 идет как второй параметр "age"
// Евген должен быть в кавычках, иначе получаем "Uncaught ReferenceError: Евген is not defined"

// Достоинство функций в том, что их можно вызывать хоть сколько раз с разными переменными:
printText2("Petr", 15) // Hello My name is Petr, Age: 15
printText2("Ivan", 17) // Hello My name is Ivan, Age: 17
printText2("Kate", 11) // Hello My name is Kate, Age: 11
printText2("Maria", 18) // Hello My name is Maria, Age: 18
// Получили 4 разных результата в консоли потому что 4 раза вызывали с разными параметрами 

// Вместо строк и чисел в качестве параметров можно вставлять переменные:

let name3 = "Евген2"
let age3 = 339
printText2(name3, age3) // Hello My name is Евген2, Age: 339

// Та же функция, но через возврат return:

function printText3 (name, age) { 
    return "Hello My name is " + name + ", Age: " + age
}

let name4 = "Евген4"
let age4 = 44
printText3(name4, age4) // В консоли ничего не появилось потому что функция вернула результат, но его нужно или присвоить переменной, или можно сразу вывести в консоль:

console.log(printText3(name4, age4)) // Hello My name is Евген4, Age: 44
// alert (printText3(name4, age4)) появилось всплывающее окно
let result = printText3("Евген5", 45)
console.log(result) // Hello My name is Евген5, Age: 45

// Вывод результата функции лучше делать не внутри функции, а снаружи как в примерах выше console.log(название функции) и alert(название функции), лобо записать результат функции в переменную а дальше выводит куда хотим и использовать как хотим.

console.log("\n --- Методы объекта")
// --- Метод объекта - это функция которая находится внутри объекта, и применяется в основном для действий с этим объектом:

let obj3 = {
    name: "Ivan",
    age: 28,
    hello () { // создли функцию с название hello, при этом function писать не надо
        console.log(`Меня зовут ${this.name}`) // с помощью this. мы можем обратиться к ключу внутри объекта в котором находимся причем результатом будет значение этого ключа
    },
}

obj3.hello() // Это мы обратились к методу внутри объекта
// Получили в консоли: Меня зовут Ivan

console.log(obj3.age) // получили 28

console.log("\n --- Метод sort - сортировка массива")

let arr_for_sort1 = [1,5,2,25,16,14,49,3,1,7]

console.log("\n let arr_for_sort1 = " + arr_for_sort1)

arr_for_sort1.sort(function(a,b){
    if (a==b) return 0
    if (a>b) return 1 // тут можно возвращать любое положительное число больше нуля
    if (a<b) return -1 // или любое отрицательное число
})
// В метод sort необходимо вставить анонимную функцию, которая позволит этому методу работать так как задумано. Без этой функции он работать не будет. Метод sort универсальный, и именно эта анонимная функция говорит методу как нужно сортировать.

// Этот метод берет 2 соседних числа, они идут как a и b и сравнивает их по нашим условиям, 0 = ничего не делать, +1 = переставить местами, -1 - ничего не делать, и так он проходится по каждой паре передвигаясь по шагу на 1 элемент.

console.log("сортировка длинным методом: " + arr_for_sort1)
// Получили отсортированный измененный массив (оригинал изменяется): 
// (10) [1, 1, 2, 3, 5, 7, 14, 16, 25, 49]

// Эту сортировку можно написать короче специальным выражением:
let arr_for_sort2 = [1,5,2,25,16,14,49,3,1,7]
arr_for_sort2.sort(function(a,b){
    return a-b
})
console.log("сортировка коротким методом .sort(function(a,b){return a-b}: " + arr_for_sort2)
// сортировка коротким методом: 1,1,2,3,5,7,14,16,25,49

// Ещё короче можно написать - через стрелочную функцию, которая во всплывающей подсказке:
let arr_for_sort3 = [1,5,2,25,16,14,49,3,1,7]
arr_for_sort3.sort((a, b) => a - b) 
console.log("сортировка стрелочной функцией .sort(a, b) => a - b: " + arr_for_sort3)
// Получили: 1,1,2,3,5,7,14,16,25,49

// Ещё один вариант записи - с фигурными скобками и return'ом:
let arr_for_sort4 = [1,5,2,25,16,14,49,3,1,7]
arr_for_sort3.sort((a, b) => {return a - b})
console.log("сортировка стрелочной функцией .sort((a, b) => {return a - b}): " + arr_for_sort3)
// Получили: 1,1,2,3,5,7,14,16,25,49
// Эти методы нужно запомнить, они сложные с заранее установленными функциями которые что-то возвращают.

// --- Задача №1. Числа Фибоначчи (https://ru.wikipedia.org/wiki/Числа_Фибоначчи)

function fibonachi(count) // count - число чисел которые мы хотим видеть в последовательности
 {
    let fib = []
    for (i=0; i<count; i++) {
        if (i==0) fib[i]=1
        else if (i==1) fib[i]=2
        else fib[i] = fib[i-2]+fib[i-1]
    }
    return fib // Возвращаем массив, он уже будет с числами. Если это не написать, получим undefined
}
let f = fibonachi(10)
console.log(f)
// Получили: (10) [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

