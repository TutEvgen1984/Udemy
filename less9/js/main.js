console.log("Раздел 9.1. Введение в JavaScript. Работа с консолью разработчика, создание переменных")

console.log('5+7') /* можно ставить одинарные и двойные кавычки */

console.log(5+7) /* в консоли вывелось "12" */

// console.log('10+7') закомментировали строку и в результате мы ничего в консоли не видим

/* Комментарий
на 3 
строки */

console.log('---')

let name = 5 /* Создаём переменную. Переменная не должна начинаться с цифр  */
var str = "10" /* если встретили в коде переменную var, то это - устаревший идентификатор, который заменили на let в 2015 году */
// тип переменных - число или текст, ява-скрипт их автоматически распознает

// переменная типа булева логика, логические переменные:
let boolean = true
let boolean2 = false
// 3 типа переменных: 
// 1. числовые,
// 2. строковые (текстовые)
// 3. логические
// Это - 3 основных типа переменных, с помощью которых делается практически всё

let name2=9.5/5.5 /* поддерживается деление, результат будет дробным с точкой. Кроме того - числа надо писать с точкой, а не с запятой */
console.log(name2) /* Вывелось в консоль 1.7272727272727273 */

let a=5
console.log(a)
a++ /* прибавление к переменной "a" единицы */
console.log(a) /* в консоли появилось: 6 */
// если написать ++ после переменной и в консоли нажать интер, то мы увидим значение переменной без операции прибавления. Но если именно вывести значение переменной то увидим с прибавлением 

++a /* такая запись даёт в консоли с помощью интер сразу результат с прибавлением единицы к переменной */
console.log(a) /* в консоли: 7 */

let b=30
b+=2 /* запись эквивалентна b=b+2 . Здесь переменная, операция, равно, и значение на которое будем выполнять операцию. Применяется тогда, когда нужно одну и ту же переменную изменить на какое-то значение */
console.log(b) /* в консоли: 32 */

// "str1"+"str2" в консоли дают результат str1str2 , то есть два текста скрепленные друг с другом

let c1="str1" 
let c2="str2"
let c3=c1+c2
console.log(c3) /* в консоль вывелось склеивание строк str1str2 */

let c="str1" 
c+="str2"
console.log(c) /* в консоль вывелось склеивание строк str1str2, результат такой же что и выше, только компактнее*/

let d=5+'str3' /* число 5 преобразуется в текст и склеится со строкой */
console.log(d) /* в консоли результат = 5str3 */

let d2=d+28
console.log(d2) /* в консоли результат = 5str328 (произошла операция склейки текста, а не математическая операция). Если на какой-то стадии число преобразовалось в текст, то оно дальше идет как текст */

let e=5+'2'
console.log(e) /* в консоли видим результат 52. Это текст потому что одно из слагаемых было текстом) */
// Это называется конкатенация

// Нам нужно «склеить» несколько значений. Операция, которая позволяет присоединить одно значение к другому, называется конкатенацией и в JavaScript выполняется с помощью знака плюс. Склеивать можно обычные строки, а можно — строки и переменные (или свойства элементов).

console.log('---')
console.log('Раздел 4.2. Строковый и логический тип данных')

let str4 = "Привет" /* переменная создана и находится в памяти браузера. Если этот код написать в консоли и выполнить интером, то консоль напишет undefined. Так и должно быть. Потом если в консоли набрать str4 и нажать интер, то увидим результат 'Привет' */

console.log("длина переменной str4.length:")
console.log(str4.length) /* В консоли вывелось: 6 */

console.log('Длинная строка'.length)  /* Это мы вычислили сразу длину строки. В консоль вывелось 14 - это кол. символов включая пробел */

console.log('Первый символ str4[0]:')
console.log(str4[0]) /* в консоли видим "П". В квадратных скобках ноль - это нулевой индекс */

console.log('Нумерация символов начинается с нуля')

console.log('6-й символ str4[5]:')
console.log(str4[5])

console.log('Если мы хотим получить последний символ, но не знаем сколько символов всего, то пишем так: str4[str4.length-1]:')
console.log(str4[str4.length-1])

// console.log(str4[3,4]) выдаёт в консоль только "е" почему-то, это аналогично str4[4]:

console.log(str4[3,4]) /* в консоли "е" */
console.log(str4[4]) /* в консоли "е" */

console.log(' ')

// Метод slice() (JavaScript Array):
// Метод slice() - позволяет возвратить новый массив, который содержит копии элементов, вырезанных из исходного массива. https://www.basicweb.ru/javascript/js_array_slice.php

console.log("str4.slice(1):")
console.log(str4.slice(1)) /* в консоли видим "ривет". Слайс с индексом 1 выдаёт все, начиная с индекса 1 и до самого конца */

console.log("str4.slice(1,3):")
console.log(str4.slice(1,3)) /* В консоли получаем "ри" - это символы с индексом 1,2 - с первого ДО 3-го, причем 3-ий индекс не включается в выборку */

console.log(' ')

// Метод toLowerCase. https://code.mu/ru/javascript/manual/string/toLowerCase/
// Метод toLowerCase преобразует символы строки в нижний регистр (из больших букв делает маленькие). При этом мы получаем новую строку, а исходная строка остается неизменной.

console.log("str5='ЗАГЛАВНЫЕ_БУКВЫ'")
let str5='ЗАГЛАВНЫЕ_БУКВЫ'

console.log("str5.toLowerCase():")
console.log(str5.toLowerCase()) /* Получили в консоли "заглавные_буквы". Если в конце метода не написать пустые скобки (), то он не выполняется */

console.log(' ')

// Метод toUpperCase https://code.mu/ru/javascript/manual/string/toUpperCase/
// Метод toUpperCase производит преобразование строки в верхний регистр (из маленьких букв делает большие). При этом возвращается новая строка, а исходная строка не меняется.

console.log("str6='строчные_буквы'")
let str6='строчные_буквы'

console.log("str6.toUpperCase():")
console.log(str6.toUpperCase()) 

console.log(' ')

// Получив неправильную строку от пользователя с неправильным количеством пробелов и неправильные заглавные буквы, нам нужно её исправить с помощью изученных методов:

console.log("let str7='  непРаВилЬная  СТРока  '")
let str7='  непРаВилЬная        СТРока  '

console.log("str7.toLowerCase() (примечание, при этом str7 остаётся неизменной)")
console.log(str7.toLowerCase())

// Метод trim
// Метод trim удаляет пробелы по краям строки. Чаще всего это нужно при вводе пользователем каких-либо значений: он может случайно налепить лишних пробелов - и наша задача очистить введенный текст от них.

console.log("let str8=str7.toLowerCase().trim()")
let str8=str7.toLowerCase().trim()
console.log(str8) 
// в консоли получили "неправильная        строка" с кучей пробелов в середине (лишние пробелы убираются методом trim() только по краям)

console.log('let str9=str8[0].toUpperCase()+str8.slice(1)')
let str9=str8[0].toUpperCase()+str8.slice(1)
console.log(str9) /* Получили "Неправильная        строка" */

console.log(' ')

// Удалим лишние пробелы в середине строки
// https://qna.habr.com/q/597048

let str10=str9.replace(/ +/g, ' ').trim()
console.log("let str10=str9.replace(/ +/g, ' ').trim()")
console.log(str10)
// Результат в консоли: "Неправильная строка" . Здесь используются регулярные выражения

// https://code.mu/ru/javascript/manual/string/replace/
// Метод replace осуществляет поиск и замену частей строки. Первым параметром принимается подстрока, которую заменяем, а вторым - подстрока, на которую заменяем.
// https://www.techiedelight.com/ru/remove-whitespaces-string-javascript/

console.log("\n     Логические типы данных и операции") /* \n - это перенос на новую строку в Java Script */

console.log("\nЛогическое И, символы &&")

// Символ &, или амперсанд, — это союз «и». Примерно в начале XIX века он был 27-й буквой английского алфавита. Рассказывая алфавит у доски, школьники говорили»…X, Y, Z, and and». Неудобно и непонятно. Тогда эту закорючку и начали называть and per se and — то есть «непосредственно and». Постепенно and per se and превратилось в ampersand (амперсанд) — современное название.

let str11=true && true
console.log("\nlet str11=true && true") /* && - это как бы блок логического И, работающий по принципу 2 из двух, на который с двух сторон приходит 2 сигнала и на выходе получаем труе или фалсе в переменной */
console.log(str11) /* результат: true */

let str12=true && false
console.log("\nlet str12=true && false")
console.log(str12) /* результат: false */

let str13=false && false
console.log("\nlet str13=false && false")
console.log(str13) /* результат: false */

console.log("\nЛогическое ИЛИ, символы ||")

// Вертика́льная черта́ — символ ASCII, имеющий код 0x7C (hex), 124 (dec). Этот символ пользователи UNIX называют «пайп», от англ. pipeline — конвейер. В первых, ещё советских, изданиях книг В. Э. Фигурнова название «pipe» было переведено как «символ трубопровода». В C-подобных языках символ "|" служит для операции побитового «или» (дизъюнкция), а два таких символа, написанных слитно ("||"), используются в операции логического «или».

let str14=true || false
console.log("\nlet str14=true || false")
console.log(str14) /* получили true */

let str15=false || false
console.log("\nlet str15=false || false")
console.log(str15) /* получили false */

// Восклица́тельный знак (!) exclamation mark (англ.) В языке Си и некоторых других языках программирования символом «!» обозначается операция логического отрицания, а сочетанием «!=» — операция сравнения «не равно». В некоторых языках используется также «!==» и другие составные знаки. В некоторых диалектах Бейсика восклицательный знак, поставленный сразу после имени переменной, означает, что эта переменная — с плавающей запятой и обычной точности.

let str16=!true /* посклицательный знак означает отрицание НЕ */
console.log("\nlet str16=!true")
console.log(str16) /* получили false */

let str17=7>5
console.log("\nlet str17=7>5")
console.log(str17) /* получили true */

let str18=7>7
console.log("\nlet str18=7>7")
console.log(str18) /* получили false */

let str19=7>=7
console.log("\nlet str19=7>=7")
console.log(str19) /* получили true */

let str20=7==7 /* Сравнение чисел. Если набрать одно равно, то выдаст ошибку синтаксиса */
console.log("\nlet str20=7==7")
console.log(str20) /* получили true */

let str21=7=='7' /* сравнили число с числом, которое в виде типа данных "строка" */
console.log("\nlet str21=7=='7'")
console.log(str21) /* получили true, Java Script произвёл приведение данных */

let str22=7==='7' /* с помощью тройного равно (строгое равно) сравнили число с числом, которое в виде типа данных "строка" */
console.log("\nlet str22=7==='7'")
console.log(str22) /* получили false потому что тройное равно сравнивает не только числа, но и типы данных */

// Разница в том, что тройное равенство является оператором строгого равенства (strict - строгий). Потому что при этом не выполняется приведение типов. Оператор строго равенства возвращает true только, когда оба значения идентичны/точно такие же.

let str23=7!='7' /* != - не равно, при этом == заменяется на !=, то есть одна равношка меняется на ! */
console.log("\nlet str23=7!='7'")
console.log(str23) /* результат: false потому что 7 равно 7 (сделано приведение типов) */

let str24=7!=='7' /* !== - СТРОГО не равно */
console.log("\nlet str24=7!=='7'")
console.log(str24) /* результат: true потому что 7 равно 7, но типы данных: слева - число, справа - строка */

let str25=5!='7' /* != - не равно */
console.log("\nlet str25=5!='7'")
console.log(str25) /* результат: true */

// Типы undefined и null - это 2 дополнительных типа данных
// undefined означает что переменная не определена
// null - пустая переменная

let g 
console.log("\nlet g")
console.log(g) /* в консоли получили undefined потому что не задали переменную, но проинициализировали её и поэтому ошибки нет в консоли. Если попробовать вывести в консоль вообще неизвестную переменную f, то появится надпись ReferenceError */

let h=null /* сделали переменную как бы пустой */
console.log("\nlet h=null")
console.log(h) /* в консоли результат null */

// null - Примитивный тип данных. Состоит из единственного значения null и обозначает отсутствие значения. Значение null используют, когда нужно обозначить намеренное отсутствие значения. В языке существует похожий примитив undefined, он обозначает, что значение ещё не установлено. Их можно легко спутать, потому что оба обозначают отсутствие значения. Разница состоит в том, что null обозначает намеренное отсутствие, а undefined — неявное. https://doka.guide/js/null-primitive/

console.log('\n---')
console.log('\n Раздел 4.3. Шаблонные строки, случайные числа, Округление чисел')

/* console.log('Текст на двух
строках') Получаем ошибку "Строковый литерал без признака конца". */
// При попытке в консоль вывести текст расположенный на 2-х строках с помощью кавычек "" и '', получаем ошибку в VSCode.

console.log(`\n Текст на 2-х
строках`) /* Специальные обратные кавычки позволяют делать текст на несколько строк, находятся на кнопке где тильда, слева над табом */

let v=47
console.log(`\n Обратные специальные кавычки и на 
второй строке переменная v= ${v}
и на 3-ей строке текст`)
// обратные кавычки - единственные кавычки в JavaScript, в которых можно использовать встраивание переменных с помощью символа доллара $ и фигурных скобок

// Ниже сделаем запись на 2 строки с помощью обычных кавычек:
console.log("\n Обычные кавычки, затем ставим n \n и оказываемся на 2-ой строке \n и на 3-ей строке выводим переменную v=" + v + " при этом в коде всё пишется в одну строку, и надо ещё обязательно писать + иначе получаем Error")

let math1=Math.random() /* Math обязательно с большой буквой. с помощью random() мы сгенерируем случайное число от 0 до 1 не включая единицу, при этом нужно обязательно ставить скобки,  возвращаемое при помощи Math.random() может быть 0, но никогда не будет равно 1 */
console.log("\n Рандомное число math1 = " + math1) /* получили в консоли рондомное число, которое при каждом перезапуске страницы меняется */

// Математический максимум:
let math2=Math.max(-5,5,10,40.88,2) /* вычисление максимального числа из ряда чисел, находящихся в скобках, перечисленных через запятую */
console.log("\n Математический максимум math2 = " + math2) /* получили в консоли 40.88 */

// Возведение в степень (метод pow)
let math3=Math.pow(2,5) /* переводе число это то что хотим возводить в степень, второе число - степень, то есть (2,5) это 2 в степени 5 */
console.log("\n Возведение в степень (метод pow). math3=Math.pow(2,5) = " + math3) /* получили в консоли 32 */

// Здесь можно извлечь корень с помощью pow, делаем степень равной 0.5 :
let math4=Math.pow(16,0.5)
console.log("\n корень из 16 методом pow math4=Math.pow(16,0.5) = " + math4) /* получили в консоли 4 */

// Для корнеизвлечения есть специальная функция sqrt. Аббревиатура SQRT — square root (англ.) - переводится как квадратный корень:
let math5=Math.sqrt(64)
console.log("\n Корень из 64 методом sqrt = " + math5) /* получили в консоли 8 */

// Округление дробного числа в меньшую сторону Math.floor(х), где х - дробное число, которое будем округлять:
let math6=Math.floor(3.9)
console.log("\n Округление дробного числа в меньшую сторону 3.9 с помощью Math.floor(3.9) = " + math6) /* получили 3 */

// Округление дробного числа в большую сторону Math.ceil. Ceiling = потолок, ceil - потолочный прилагательное :
let math7=Math.ceil(3.1)
console.log("\n Округление дробного числа в большую сторону 3.1 с помощью Math.ceil(3.1) = " + math7) /* получили 4 */

// Округление дробного числа по стандартным математическим правилам Math.round(x), где x - переменная которую округляем:
let math8=Math.round(3.5)
console.log("\n Округление дробного числа 3.5 с помощью Math.round(3.5) = " + math8) /* получили 4 */
let math9=Math.round(3.4)
console.log("\n Округление дробного числа 3.4 с помощью Math.round(3.4) = " + math9) /* получили 3 */

// Есть метод округления trunc который просто убирает дробную часть, какой бы она не была. truncate - усекать, укоротить.
// trunc() — отбрасывание дробной части, не обращая внимания на знак аргумента.
// https://doka.guide/js/math-floor/
let math10=Math.trunc(7.444)
console.log("\n Округление дробного числа 7.444 с помощью Math.trunc(7.444) = " + math10) /* получили 7 */

// Округление до фиксированного количества знаков после запятой toFixed(x), где х - количество знаков после запятой:
let math11=9.56561648
let math12=math11.toFixed(3)
console.log("\n Округление дробного числа 9.56561648 с помощью math11.toFixed(3) до 3-х знаков после запятой = " + math12) /* получили 9.566, при этом .5656 округлилось по правилам математики до 0.566 */

// Действие преобразующее строку в число:
let math13="42"
let math14=math13+2
console.log("\n math13='42'+2 = " + math14) /* получили 422 (произошла контагенация) */
let math15=+math13+2
console.log("\n Добавим один + перед строковой переменной. math15=+math13+2 = " + math15) /* получили 44 (контаценации не произошло). Это мы как бы самостоятельно конвертируем строки в числа */

// Встроенная функция для проверки является ли переменная числом isFinite() (конечный, ограниченный, финитный):
math16="300"
console.log("\n Встроенная функция для проверки - является ли переменная числом - isFinite('300') = " + isFinite(math16)) /* получили true */

console.log("\n Встроенная функция для проверки является ли переменная числом isFinite('str78') = " + isFinite("str78")) /* получили false */

function randomInteger(min,max) /* эта функция вычисляет рандомное целое число в пределах минимума и максимума задаваемых пользователем. Обычно эти функции берутся где-нибудь из интернета (https://learn.javascript.ru/task/random-int-min-max) */
{
    let rand = min + Math.random() * (max + 1 - min);
    return Math.floor(rand);
}

console.log("\n Используем лично созданную функцию создания рандомного числа randomInteger(1,5) = " + randomInteger(1,5)) /* получаем случайное целое число, которое меняется при каждой перезагрузке страницы  */
// (max + 1 - min) используется для того, чтобы намеренно прибавить +1 и получить при пределах 1-5 0,98(теоретический выскочивший рандом)*5=4.9 который потом плюсуется с мин = 1, получаем 5.9, и округляем вниз до 5. То есть этот + 1 даёт большую вероятность получить ровно 5, иначе если +1 не написать, то 5 по стандартному решению через random будет выпадать крайне редко. Есть простой метод округления без всяких +1, округление простым round-ом, но тогда там будут проблемы с низкой веротностью получения крайних значений, получится неравномерная характеристика вероятностей.


/* 
Вопрос №1: Как перевести текст на новую строку?
Ответ №1: \n
*/

console.log("\n --- \n 9.4 Массивы")

let arr = [5,2,"Str1", true] /* array (англ.) = массив */
console.log("\n Массив arr: " + arr) /* получили  Массив arr: 5,2,Str1,true */
console.log(arr) /* получили вертикальное раскрывающееся меню с массивом */

console.log("\n Длина массива arr.length = " + arr.length) /* получили 4 */

console.log("\n Выведем элемент 2 массива. arr[2] = " + arr[2]) /* получили Str1 */

console.log("\n Изменим элемент 2 массива. arr[2] = 'Text' ")

arr[2] = "Text" /* Примечание: Не нужно писать let если хотим присвоить новое значение индексу массива. Если написать let то пишет кучу ошибок в стиле "невозможно присвоить объект" */

console.log("\n Выведем элемент 2 массива. arr[2] = " + arr[2]) /* Получили 'Text' */

console.log("\n Массив arr:" + arr) /* Получили массив в строку, без меню */

console.log(arr) /* получили массив в виде меню, и видно что "Str1" поменялось на "Text" */

// Далее добавим в массив значение в индекс 5, при этом этого индекса 5 в массиве нет

arr[5] = 7 /* Написали присвоение индексу 5 массива arr значение 7 */

console.log("\n Написали присвоение индексу 5 массива arr значение 7: arr[5] = 7")

console.log("\n Массив arr:" + arr) /* Получили массив с 7 на индексе 5, а на 4 идексе ничего не было, поэтому там написано ",," */

console.log(arr) /* Получили массив в виде меню, с 7 на индексе 5, а на 4 идексе ничего не было, поэтому там написано "пусто" */

// Матрицы:
console.log("\n Матрицы:")

// Создадим матрицу из 3-х массивов в каждом по 3 элемента
let matrix = [
    [1.1,1.2,1.3],
    [2.1,2.2,2.3],
    [3.1,3.2,3.3]
]

console.log(matrix) /* Получили массив в виде меню, у которого написано "(3) [Array(3), Array(3), Array(3)]" и если раскрыть массив, то видно матрицу по три значения в каждой из 3-х строк */

console.log("\n Матрица = " + matrix) /* если вывести с текстом перед самой матрицей, то видим все числа в строку " Матрица = 1.1,1.2,1.3,2.1,2.2,2.3,3.1,3.2,3.3" */

console.log("Вывели элемент в центре матрицы: matrix[1][1] = " + matrix[1][1]) /* Видим 2.2 */
// То есть мы берем массив с индексом 1 и в нем обращаемся к индексу 1. 
// matrix[индекс массива][индекс элемента в массиве]

// Далее получение элемента массива с помощью .length
console.log("\n Неправильно обратимся к посленему индексу массива arr[arr.length] = " + arr[arr.length]) /* видим в консоли undefined потому что length равен числу от 1 до последнего, а индексы у нас нумеруются с нуля, и получается что мы обратились к индексу на единицу больше чем есть */

console.log("\n Последний индекс arr[arr.length-1] = " + arr[arr.length-1])

// Далее разберем ОЧЕРЕДЬ с методом PUSH и SHIFT

// Метод SHIFT (выбросить первый элемент):

console.log("\n ОЧЕРЕДЬ с PUSH и SHIFT:") 

console.log("\n Изначальный массив arr: " + arr) 

console.log("\n Выбросим первый элемент с помощью конструкции arr.shift()") 

arr.shift() /* Выбрасывание первого элемента и массива. В скобки ничего писать не надо */

console.log("\n Массив после выбрасывания элемента: " + arr) /* Видим, что нет первого элемента, в котором было число 5, и при этом все элементы сдвинулись влево и число 2 стало первым (было вторым) */

// Метод UNSHIFT(добавляемый элемент) - Добавление элемента в начало очереди

console.log("\n Добавим в начало массива новый элемент с помощью конструкции arr.unshift('Первый элемент')") 

arr.unshift("Первый элемент")

console.log("\n Массив после добавления элемента с помощью unshift: \n" + arr)

// Метод PUSH (x) , где x - добавляемый элемент. Добавление элемента в массив в конец очереди)

console.log("\n Изначальный массив arr: " + arr) 

console.log("\n Добавим в конец массива новый элемент с помощью конструкции arr.push('Последний элемент')") 

arr.push("Последний элемент") /* Если такой код набрать в консоли и нажать интер, то появится "4" - это длина нового массива */

console.log("\n Массив после добавления нового элемента (который автоматически добавляется в конец массива): " + arr) /* Первый элемент,2,Text,true,,7,Последний элемент */

// Далее разберем STACK (стопка, кипа бумаг в переводе с англ.) в котором мы помещаем что-то в конец и забираем тоже с конца. Методы Push и POP

console.log("\n STACK, стэк, стопка или кипа бумаг:")

// Метод PUSH (добавление элемента в массив в конец очереди) мы уже знаем

// Метод POP (извлечение последнего элемента)

console.log("\n Изначальный массив arr: " + arr) /* Первый элемент,2,Text,true,,7,Последний элемент */ 

console.log("\n Извлечем из конца массива последний элемент с помощью конструкции arr.pop(). В скобки ничего писать не надо") 

arr.pop() /* Извлечение последнего элемента */

console.log("\n Массив после arr.pop(): " + arr) /* Видим "Массив после arr.pop(): Первый элемент,2,Text,true,,7". Исчез "Последний элемент" */

/* Итого:

1. Очередь
 1.1 PUSH - добавление в конец очереди
 1.2 Shift - убрать из начала очереди
 1.3 Unshift - добавить в начало очереди

 2. СТЭК (Stack)
2.1 PUSH - добавление в конец стопки
2.2 POP - убрать из конца стопки

*/

// Метод concat (конкатенация) для массивов

// Создадим массив №2
let arr2 = [21,22,22]
console.log("\n Новый массив arr2= " + arr2)

// Моздадим массив №3 который будет состоять из массива №1 к которому присоединим массив №2:

let arr3 = arr.concat(arr2) /* сначала пишем массив 1 к которому хотим присоединить, затем метод конкатенации у которого в скобках массив 2 который присоединится к первому */

console.log("\n Написали команду arr3 = arr.concat(arr2)")

console.log("\n Новый массив arr3 = " + arr3) /* видим Первый элемент,2,Text,true,,7,21,22,22 */

// Метод indexOf (вычисление индекса известного нам элемента):
console.log("\n Метод indexOf. Вычисляет индекс определенного элемента в массиве")
console.log("\n arr3.indexOf(22) = " + arr3.indexOf(22)) /* видим 7. При этом там есть ещё один 22 на индексе 8, но показывает только один индекс 7 */

// Если мы знаем что в массиве есть элемент, то мы можем вычислить его индекс с помощью метода indexOf

// Метод join (объединение индексов):

console.log("\n Создадим новый массив arr4 = [41,42,42]")

let arr4 = [41,42,42]

arr4.join() /* Если так написать, то такая запись склеивает все значения массива в новую переменную в памяти как бы, склеивает по умолчанию ставя между элементами запятые, но не изменяет исходный массив, и для того чтобы запомнилось это новое изменение, нужно присвоить какой-то новой переменной это преобразование этим методом. Запись аналогична arr4.join(",") */
console.log("\n Написали комманду arr4.join()")

console.log("\n Выводим массив arr4 и видим, что он не поменялся:")

console.log(arr4)

let arr5 = arr4.join()

console.log("\n Написали комманду: let arr5 = arr4.join()")

console.log("\n Выводим массив arr5 и видим, что он состоит из одного индекса, но элементы склены по умолчанию через запятую")

console.log(arr5)

let arr6 = arr4.join(" / ")

console.log("\n Написали комманду: let arr6 = arr4.join(' / ') и получаем массив из склееных элементов через наклонную черту:")

console.log(arr6)

let arr7 = arr4.join("")

console.log("\n Написали комманду: let arr7 = arr4.join('') и получаем массив из склееных элементов монолитно без разделителей:")

console.log(arr7)

// Универсальный метод splice для массивов, который позволяет добавлять, удалять и заменять любые элементы в массивах:

console.log("\n Метод splice:")

let arr_for_splice = ["Эл1", "Эл2", "Эл3", "Эл4", "Эл5" ]

console.log("\n Выводим массив arr_for_splice: " + arr_for_splice) 
// Получили: Эл1,Эл2,Эл3,Эл4,Эл5

// Далее удалим 1 элемент:

let arr31 = arr_for_splice.splice(1,1) /* удаляем элементы начиная с индекса №1, количество этих элементов = 1 */
// Первый параметр в скобках - это начальный индекс. 
// Второй параметр - это количество удаляемых элементов.
// Третий необязательный параметр - объект который вставится взамен удаленного

console.log("\n let arr31 = arr_for_splice.splice(1,1)") 

console.log("\n Массив arr31 сделавший splice : " + arr31) /* Получили Эл2 потому что после splice мы получаем то что вырезаем */

console.log("\n Выводим массив arr_for_splice: " + arr_for_splice) 
// Получили: Эл1,Эл3,Эл4,Эл5. "Эл2" между Эл1 и Эл3 исчез.  
// То есть метод splice удаляет элемент из оригинального массива изменяя оригинальный массив. А то что он удалил можно отдельно в другую переменную положить

// Далее удалим все элементы начиная с индекса 1: 

let arr32 = arr_for_splice.splice(1)
// Такая запись удалит из массива все элементы начиная с индекса 1 включительно

console.log("let arr32 = arr_for_splice.splice(1)")

console.log("\n Массив arr32 сделавший splice : " + arr32) /* Получили Эл3,Эл4,Эл5 потому что после splice мы получаем то что вырезаем */

console.log("\n Выводим массив arr_for_splice: " + arr_for_splice) 
// Получили: Эл1. Все последующие элементы исчезли

// Далее ничего не удаляя добавим 5 элементов

let arr33 = arr_for_splice.splice(1,0, "Новый элемент 10","Эл11",42,33,34)
// Такая запись означает: начиная с первого индекса включительно удалить 0 элементов, и добавить много элементов далее. То есть мы здесь только добавляем.
// В такой операции не нужно на самом деле let arr33 потому что массив arr33 будет пустым. Эту операцию нужно просто выполнить.   

console.log("\n let arr33 = arr_for_splice.splice(1,0, 'Новый элемент 10','Эл11',42,33,34)")

// console.log(arr33) - Такая запись выводит пустой массив без элементов почему-то

console.log("\n Выводим массив arr_for_splice: " + arr_for_splice) 
// Получили: Эл1,Новый элемент 10,Эл11,42,33,34. То есть к Эл1 добавилась куча элементов

// Далее удалим два индекса №3 и №4 (число 42 и 33) и вставим новый один элемент (число 52)

arr_for_splice.splice(3,2,52)

console.log("\n Далее удалим 2 индекса №3 и №4(число 42, 33) и заменим его на 1 новый (число 52): arr_for_splice.splice(3,2,52)")

console.log("\n Выводим массив arr_for_splice: " + arr_for_splice)
// Получили Эл1,Новый элемент 10,Эл11,52,34 
// Видим что числа 42,33 исчезли, и взамен них появилось одно 52

// Метод splice поддерживает отрицательные значения:

arr_for_splice.splice(-1,0,"Вставка -1") /* -1 отрицательный индекс в самом начале скобок означает что считая с конца на 1 элемент раньше выполнить действие - ничего не делать (второе значение 0) - и затем вставить Элемент. Короткр: вставили перед последним элементом. */

console.log("\n Выводим массив arr_for_splice: " + arr_for_splice)
// Видим: Эл1,Новый элемент 10,Эл11,52,Вставка -1,34
// Между 52 и 34 появился элемент "Вставка -1". Вставили перед последним элементом
// Если индекс -2 написать, то будет операция перед предпоследним индексом.

// Метод slice - возвращает нам какое-то количество элементов массива не портя оригинал

console.log("\n Метод slice:")
let arr_for_slice = ["Эл21", "Эл22", "Эл23", 4, false, 6, 7, 8]

console.log("\n Новый массив arr_for_slice: " + arr_for_slice)

let arr34 = arr_for_slice.slice(0,3) /* Элементы с индекса 0 до индекса 3 не включительно вернуть в новый массив не повреждая оригинал. Будут 3 элемента: 0,1,2 */

console.log("\n let arr34 = arr_for_slice.slice(0,3)")

console.log("\n массив arr_for_slice не изменился :" + arr_for_slice)

console.log("\n массив arr34:" + arr34)

// Получили массив arr34:Эл21,Эл22,Эл23

let arr35 = arr_for_slice.slice(4) /* Вернутся элементы начиная с индекса и до конца*/

console.log("\n let arr35 = arr_for_slice.slice(4)")

console.log("\n массив arr35:" + arr35)

// Получили: массив arr35:false,6,7,8

let arr36 = arr_for_slice.slice(-2) /* получить массив из предпоследнего элемента и до конца, или коротко говоря последние 2 элемента массива */

console.log("\n let arr36 = arr_for_slice.slice(-2)")

console.log("\n массив arr36:" + arr36)
// Получили: массив arr36:7,8


let arr37 = arr_for_slice.slice(-4,-1) /* скопировать вырезку от 4-го элемента с конца до последнего не включая последний */

console.log("\n let arr37 = arr_for_slice.slice(-4,-1)")

console.log("\n массив arr37:" + arr37)
// Получили:  массив arr37:false,6,7


// --- Метод includes проверяет есть ли какой-то элемент в нашем массиве. Результат булевый ---

console.log("\n Метод includes:")

let arr_for_inclides = ["Эл1", "Эл2", "Эл3", "Эл4", "Эл5", "Эл6"]

console.log("\n Новый массив arr_for_inclides: " + arr_for_inclides)

let var_includes1 = arr_for_inclides.includes("Эл4") /*  */

console.log("\n let var_includes1 = arr_for_includes.includes('Эл4')")

console.log("\n var_includes1 = " + var_includes1)
// Получили true


let var_includes2 = arr_for_inclides.includes("эл4")

console.log("\n let var_includes2 = arr_for_inclides.includes('эл4')")

console.log("\n var_includes2 = " + var_includes2)
// Получили false потому что тут важен регистр. "эл4" и "Эл4" это разные элементы


// --- Метод reverse() вовращает нам массив с элементами в обратном порядке: ---

console.log("\n Метод reverse():")

let arr_for_reverse = ["Эл31", "Эл32", "Эл33", 4, false, 6, 7, 8]

console.log("let arr_for_reverse = " + arr_for_reverse)

let arr40=arr_for_reverse.reverse() /* применили метод переворачивания */

console.log("arr40=arr_for_reverse.reverse() = " + arr40)
// Получили 8,7,6,false,4,Эл33,Эл32,Эл31 . Массив перевернулся

console.log("оригинальный массив arr_for_reverse перевернулся = " + arr_for_reverse)
// Получили 8,7,6,false,4,Эл33,Эл32,Эл31. То есть оригинал тоже перевернулся

arr_for_reverse.reverse() /* применили метод переворачивания ещё раз чтоб вернуть всё на место*/

console.log("arr_for_reverse.reverse() - переворачиваем обратно")

console.log("оригинальный массив arr_for_reverse вернулся в исходное положение = " + arr_for_reverse)

// --- Метод split. Расщепляет монолитную строку на массив из отдельных элементов. 

let str_for_split = "Эл41, Эл42, Эл43, Эл44, Эл45" /* строка монолитная для расщепления на массив */

let arr_after_split1 = str_for_split.split() /* Если так написать и ничего не указать в скобках, то получим массив с одним единственным индексом 0 и длиной 1 */

console.log("let arr_after_split1 = str_for_split.split() - НЕправильный код")

console.log(arr_after_split1) /* получили массив со строкой в виде единственного индекса 0 ['Эл41, Эл42, Эл43, Эл44, Эл45']*/

// Чтобы разделить на отдельные элементы, нужно в скобках указать используемый разделитель, в нашем случае это "запятая пробел" ", " :

let arr_after_split2 = str_for_split.split(", ")

console.log('let arr_after_split2 = str_for_split.split(", ") - Правильный код')

console.log("\n Массив после разделения: " + arr_after_split2)
console.log(arr_after_split2)
// Получили: (5) ['Эл41', 'Эл42', 'Эл43', 'Эл44', 'Эл45'] - массив с отдельными 5 элементами

// Далее сделаем то же самое для строки у которой к вачестве разделителей выстпает ТИРЕ:
console.log("\n Далее сделаем то же самое для строки у которой к вачестве разделителей выстпает ТИРЕ:")

let str_for_split2 = "Эл41-Эл42-Эл43-Эл44-Эл45" /* строка с ТИРЕ в качестве разделителей */

console.log('\n let str_for_split2 = "Эл41-Эл42-Эл43-Эл44-Эл45"')

let arr_after_split3 = str_for_split2.split("-")

console.log('\n let arr_after_split3 = str_for_split2.split("-")')

console.log(arr_after_split3)
// Получили: (5) ['Эл41', 'Эл42', 'Эл43', 'Эл44', 'Эл45'] - массив с отдельными 5 элементами


// С помощью split можно разделить слово на массив состоящий из отдельных букв:
console.log("Разделим одно слово на массив состоящий из отдельных букв")

let str_for_split3 = "Разделить"

console.log('let str_for_split3 = "Разделить"')

let arr_after_split4 = str_for_split3.split("") /* d кавычках ничего не указываем, но кавычки должны быть */

console.log('let arr_after_split4 = str_for_split3.split("")')

console.log(arr_after_split4)
// Получили: (9) ['Р', 'а', 'з', 'д', 'е', 'л', 'и', 'т', 'ь']

// Шаг 3. Проверочный вопрос.
// Сопоставьте значения из двух списков
// Извлечь последний элемент -> POP
// Извлечь первый элемент -> Shift
// Добавить элемент в конец -> PUSH

// --- 9.5 Объекты ---
console.log("\n --- 9.5 Объекты ---")

console.log("\n Создадим объект:")

let obj = {
    "color": "Tomato", /* {"Ключ": значениие} это ключ №1*/
    "numbers": [888, 777], /* ключ №2 */
    "checked": true /* ключ №3 */
}
/* Ключи - это строковые переменные. В качестые значений может быть что угодно: строка, число, булева логика, функция, массив, или даже другой объект */

console.log(obj)
// Получили {color: 'Tomato', numbers: Array(2), checked: true}

console.log('\n Выведем в консоль не весь объект, а только один из ключей объекта: ')

console.log('\n obj["color"]: ') /* Это похоже на вызов из массива индекса с помощью квадратных скобок [], только здесь указываем не числовой индекс, а в кадртаных скобках ключ заключенный в кавычки */

console.log(obj["color"]) /* Вызвали с помощью квадратных скобок и ключа из объекта цвет. Получили: Tomato */

console.log('\n obj.color: ')
console.log(obj.color) /* Вызвали с помощью точки и ключа из объекта цвет. Получили то же самое: Tomato */

console.log('\n obj.numbers[1]: ')
console.log(obj.numbers[1]) /* Вызвали с помощью точки из объекта массив чисел и из него число индексом 1. Получили: 777 */

console.log('\n obj["numbers"][1]: ')
console.log(obj["numbers"][1]) /* Вызвали с помощью квадратных скобок из объекта массив чисел и из него число индексом 1. Получили то же самое: 777 */

// Чтобы узнать какие существуют ключи у объекта, существует следующая конструкция:

console.log('\n Object.keys(obj): ')

console.log(Object.keys(obj)) /* то есть пишем Object.keys и в скобках имя нашего объекта. При этом Object пишется с большой буквы */
// Получили для нашего объекта массив в виде ключей: (3) ['color', 'numbers', 'checked']. Только в них не видно что внутри ключей имеется, поэтому нагляднее и легче вывести весь объект целиком

// Добавим в объект новый ключ со значением, которого у нас раньше не было:

console.log('\n Добавим в объект новый ключ со значением, которого у нас раньше не было:')

console.log('\n obj["name"] = "Ivan"')

obj["name"] = "Ivan" /* присвоили новый ключ и значение, причем, в отличии от массивов, тут не нужно соблюдать числовую последовательность индексов. let тоже не требуется  */

console.log(obj) 
// Получили раскрывающийся объект: {color: 'Tomato', numbers: Array(2), checked: true, name: 'Ivan'}
// Что примечательно, они выводятся не в том порядке в котором мы их вводили, а в неупорядоченном непонятно как

// Массив с объектами без названий:

console.log('\n Массив с объектами без названий:') 

let arr_of_three_obj = [
    {
        "color": "Tomato1",
        "numbers": [888, 777],
        "checked": true
    },
    {
        "color": "Tomato2",
        "numbers": [888, 777],
        "checked": false
    },
    {
        "color": "Tomato3",
        "numbers": [888, 12],
        "checked": false
    }
]

console.log(
    `let arr_of_three_obj = [
        {
            "color": "Tomato1",
            "numbers": [888, 777],
            "checked": true
        },
        {
            "color": "Tomato2",
            "numbers": [888, 777],
            "checked": false
        },
        {
            "color": "Tomato3",
            "numbers": [888, 12],
            "checked": false
        }
    ]
    `
)

console.log(arr_of_three_obj)
// Получили раскрывающийся массив: (3) [{…}, {…}, {…}]

console.log('\n console.log(arr_of_three_obj[0]["color"])')

console.log(arr_of_three_obj[0]["color"]) /* Получили: Tomato1 */

console.log(arr_of_three_obj[2]["numbers"][1]) /* Получили: 12 */

/* Вопрос: 
Заполните пропуски
Ответ: Объект на JavaScript состоит из пары: ключ и значение */

// --- 9.6. Диалоговые окна, Тернарный оператор, Переключатель Switch ---

console.log("\n --- 9.6. Диалоговые окна, Тернарный оператор, Переключатель Switch ---")

console.log('\n Функция alert (англ. тревога, оповещение):')

/* alert("Текстовая строка") */ /* получаем всплывающее маленькое окно в котором написано "Уведомление от сайта 127.0.0.1" "Текстовая строка" и кнопочка "Закрыть" внизу */

// При этом на странице идет постоянно как бы загрузка. И это означает что пока мы не нажмем "Закрыть", весь код набранный после alert, не будет выполняться. После того как нажмем "Закрыть" окно исчезает и выполняется код ява-скрипта дальше.

console.log('\n Функция prompt (англ. запрос):')

/* prompt("Введите ваш возраст") */ /* от англ. запрашивать, запрос, побуждать */
// Получили: Второе всплывающее окно в котором написано "Введите ващ возраст" и ниже поле для ввода текста с мигающим курсором, и ниже 2 кнопки "Продолжить" и "Отмена". После введения возраста и нажатия любой кнопи "продолжить" или "Отмена" окно исчезает, при этом введеннные значения никуда не записываются и не запоминаются. Чтобы они запомнились, нужно использовать присвоение переменной, о чём далее.

/* let age = prompt("Введите ваш возраст") */ /* Вылетело первое всплывающее окно с полем ввода текста, в которое вводим 39 и нажимаем внизу кнопку "Продолжить" */

/* alert(`Мой возраст = ${age}`) */ /* Вылетело 2-ое всплывающее окно с надписью "Мой возраст = 39". Если же при вводе возраста нажать "Отмена", то получим "Мой возраст = null", что означает что переменная пустая. Если в поле возраста ввести апр, то выведется "Мой возраст = апр" */

// Условия:

// Зачем выводить null если пользователь ничего не ввел? Для того чтобы этого не было нужно использовать условие if  

/* if (age != null){
    alert(`Мой возраст = ${age}`)
}*/ 
// В круглых скобках написано условие что возраст не должен быть равен ничему
// В фигурных скобках пишем что должно выполниться если условие истина
// В итоге получилось: если пользователь ввел что-то в запросе промпт, то появляется второе окно алерт, где написан текст + возраст
// тут можно еще добавить необязательное условие else

/* if (age != null){
    alert(`Мой возраст = ${age}`)
} else {
    alert(`Вы нажали Отмена`) 
} */
// алерт выполнится только если age=null, то есть только если пользователь нажал Отмена
// Но остается еще загвоздка заключающаяся в том, что если пользователь ничего не ввел и нажал "Продолжить", то это не null, это - как бы пробел - и мы получаем окно алерт с надписью "Мой возраст =  "

console.log('\n Функция confirm (англ. подтвердить):')

// Всплывающее окно confirm работает так, что появляется всплывающее окно, в котором есть какой-то вопрос, и есть только две кнопки "Да" и "Нет". 

/* if (confirm("Удалить ваш аккаунт?")) 
{
    alert("Аккаунт удалён") /* Это выполнится если пользователь нажмет "Да" 
} 
else {
    alert("Отменено") /* Выполняется при нажатии кнопки "Нет" 
} */
// Если else не написать, то при нажатии "Нет" ничего не происходит - окно всплывающее исчезает и всё.
 
console.log('\n Тернарный оператор - аналог условия if :')

// confirm("Удалить ваш аккаунт?") ? alert("Аккаунт удалён") : alert("Отменено")
// После вопроса (?) указываем код, который будет выполнен в случае если условие будет ИСТИНО, а потом двоеточие (:) , после чего действие в случае ЛОЖЬ.

// В итоге длинный код if с else на 8 строк записан очень коротко в виде одной строки

// Здесь может быть только одна строка. И применяется это только для таких коротких вариантов записи - где выполняется только одно действие для ИСТИНЫ и одно действие для ЛЖИ. Можно в скобках указать несколько действий, но не рекомендуется этого делать. Когда более одного действия - рекомендуется использовать if с фигурными скобками.

// --- Составные условные конструкции:
console.log("\n --- Составные условные конструкции:")

// let age = prompt("Введите ваш возраст")

// Код на основе стандартных if - else if:
// if (age < 18){
//     alert("Мой возраст меньше 18") /* получили это окошко когда ввели 17 */
// } else if (age > 18) {
//     alert("Мне больше 18")  /* получили это окошко когда ввели 20 */
// } else if (age == 18) { /* else if (age == 18) -> else {} получим то же самый результат */
//     alert("Мне 18")  /* получили это окошко когда ввели 18 */
// }

// Функция Switch (англ. переключатель) - аналог if-else. Применяется когда много условий, в нем они будут нагляднее:

// let age = prompt("Введите ваш возраст")
// switch(true) { /* true - это то с чем мы сравниваем дальнейшие условия */
//     case age > 18 : 
//         alert("Мне больше 18")
//         break /* с помощью break мы выходим из switch и это нужно чтобы не выполнялся дальнейший код в свиче */
//     case age < 18 && age > 0: /* проверяются 2 условия через логику И. Если этого не написать, то при вводе -20 получим "Мой возраст меньше 18" */
//         alert("Мой возраст меньше 18")
//         break
//     case age == 18:
//         alert("Мой возраст 18 лет")
//         break
//     default : /* это аналог else, который срабатывает когда не было выполнено никаких действий до него */
//         alert("Неправильный возраст") /* Появляется при числах <=0 и при кнопке Отмена */
// }
// В результате кода по количеству строк получилось не меньше чем в стандартном if-else

// Вопрос:
// Сопоставьте
// Окно для ввода = prompt
// Окно с подтверждением и отменой = confirm
// Окно с текстом = alert

// --- 9.7 Циклы + практика ---
console.log("--- 9.7 Циклы + практика ---")

// --- Цикл While:
console.log("--- Цикл While:")

let count = 0

while (count < 10) {
    console.log(count) /* получили в консоли 5 строк с цифрами от 0 до 4 */
    if (count == 4) {break} /* Обязательно два равно, если одно то цикл выдаёт 0 в консоль и дальше не работает. Можно еще 3 равно для полного сравнения включая число и тип. Break останавливает цикл while */
    count++ /* прибавляем к счетчику единицу */
    // Если прибавление не написать, то бесконечно выводятся цифры в консоль влоть до миллионов, это не цифры нашего счетчика, это счетчик количества выполненных действий браузером, выводится ноль 500 000 раз, и процессор загружается почти на 100% и браузер тоже виснет, снятие задачи в диспетчере надо выполнять. Это потому что count всегда остается 0 и не изменяется, и выполняется цикл вывода одного и того же числа в консоль бесконечно
}

console.log(`count = ${count}`) /* Получили 4, значит после сработавшего break не успело выполниться count++ */

console.log("--- Цикл do while:")

console.log("--- Цикл №1:")
let count2 = 10
do {
    console.log(count2) /* получили в консоли 1 строку с цифрой 10 */
    count2++ /* в конце count2 становится = 11, но в консоль оно не выводится потому что условие while сработает на останов */
} while (count2 <7 ) /* первоначальное условие уже изначально завершает цикл потому что 10>7 и получаем false */

console.log(`count2 = ${count2}`) // Получили 11. 

// То есть этот цикл иногда бывает необходим - когда сначала надо выполнить тело 1 раз, а потом уже сделать проверку условия, и если условие true то выполнить 2-ой раз, а если false, то закончить цикл. Стандартный цикл while сначала проверяет, и может ни разу не выполнить тело. 

console.log("--- Цикл №2:")
let count3 = 20
do {
    console.log(count3) /* получили в консоли 3 строки: 20, 19, 18 */
    count3-- /* count3-- при каждом цикле уменьшается на 1. В конце count3 становится = 17, но мы в консоль оно не выводится потому что условие while сработает на останов */
} while (count3 >17 )

console.log(`count3 = ${count3}`) /* получили 17, значит тело выполнилось, сминусовало переменную count3, потом проверка с результатом false, и цикл обрывается */

console.log("--- Цикл for:")
// Это самый распространенный цикл. Если нам нужно выполнить код например 5 раз, то используем его.

console.log("--- Цикл №1:")
for (let i=1; i<=5; i++) 
/* сначала присваиваем переменной начальное значение и не забываем let; затем условие выполнения цикла "выполнять до тех пор пока..."; изменение переменной при каждом цикле */
{
    console.log(i) /* получили в консоли 1, 2, 3, 4, 5 */
}

// console.log(`i = ${i}`) результат "i is not defined" то есть i в цикле for используется временно и только во время цикла, и потом удаляется из памяти

console.log("--- Цикл №2:")
for (let i=20; i>=14; i-=2) {
    console.log(i)
}
// С 20 до 14 включительно выводим в консоль i и при каждом цикле уменьшаем на 2
// Получили: 20, 18, 16, 14.

console.log("--- Цикл №3. Применение for для работы с массивом:")

let arr_for_circleFOR = [5, 7, 9, 1, 0]

console.log(`arr_for_circleFOR = ${arr_for_circleFOR}`)

for (let i=0; i<arr_for_circleFOR.length; i++) {
    console.log(arr_for_circleFOR[i]*=2) /* каждый элемент умножается на 2, причем изменяется оригинальный массив. Получили 5 строк по 1 числу в каждом, умноженным на 2 */
}
console.log(`arr_for_circleFOR = ${arr_for_circleFOR}`)
// Получили: 10,14,18,2,0.
// В итоге мы перебрали массив по элементам, где с каждым элементом провели математическую операцию изменив оригинальный массив

console.log("--- Цикл for of для массивов:")

console.log("--- Цикл №1. Простой вывод элементов массива")
// Этот цикл - специальная более краткая версия цикла for для перебора элементов без присваивания значений и вычислений последнего элемента

for (let item of arr_for_circleFOR) {
    console.log(item) // Получили: 10,14,18,2,0
    console.log(item*2) // Получили: 20,28,36,4,0
}
console.log(`arr_for_circleFOR = ${arr_for_circleFOR}`)
// Получили 10,14,18,2,0. То есть такое выражение только выводит элементы, но не изменяет их в оригинальном массиве 
// let item - это как бы присвоение к любой временной переменной с любым названием значений в массиве методом перебора. Тут можно написать вместо item любое название, например i, index и так далее 

// console.log("--- Цикл №2. Умножене элементов массива на 2")
// for (let item of arr_for_circleFOR) {
//     // console.log(item*=2) // такая запись умножит на 2, введет в консоль, но не изменит оригинал
//     // item*=2 и такая - тоже не изменит
//     // console.log(arr_for_circleFOR[item]*=2) // а так вообще сплошные ошибки NaN потому что item это сам элемент, а не индекс, и получается что например если item получился 98, то мы пытаемся вывести в консоль arr_for_circleFOR[98], то есть элемент с индексом 98 (которого в данном массиве нет). 
// }
// console.log(`arr_for_circleFOR = ${arr_for_circleFOR}`)

// Цикл for of применяется не только к масивам, особенно хорошо он работает с html-элементами.

console.log("--- Цикл for in для объектов:")
// У объектов используются ключи, а не индексы. Поэтому для объектов был создан специально этот цикл

let obj2 = {
    "name": "Евген", 
    "age": 39,
    "number": 89234076582,
}
// в конце это - висячая запятая, облегчает добавление/удаление/сортировку кллючей

for (let key in obj2) {
    console.log(key) // выводим название ключа
    console.log(obj2[key]) // выводим значение ключа 
}
// Получили 6 строк:  name, Евген, age, 39, number, 89234076582 

for (let key in obj2) {
    console.log(`Ключ ${key}, значение ${obj2[key]}`)
}
// Получили 3 строки: 
// Ключ name, значение Евген, 
// Ключ age, значение 39
// Ключ number, значение 89234076582 

// этот цикл не рекомендуется применять к обычным массивам потому что он может вернуть и те ключи, которые мы не хотим видеть (это ключ у массива length и _proto_). 

// --- Дополнительная работа с массивами: ---

// * Метод forEach. Этот новый метод недавно появился, с помощью него можно проходить по элементам массива и что-то с ними делать
console.log("--- Метод forEach для массивов:")

let arr_for_addition = [5, 7, 9, 1, 0]
arr_for_addition.forEach(function(item, index, array){ // Анонимная функция с 3 параметрами: значение, индекс, массив. Названия переменных - любое, важен их порядок объявления в функции, и используются они временно, поэтому названия могут совпадать с используемыми вроде как.
    console.log(`Элемент: ${item}
    Удвоенный элемент: ${item*2}
    Индекс: ${index}
    Массив: ${array}`)
})
// Получили:

// Элемент: 5
// Удвоенный элемент: 10
// Индекс: 0
// Массив: 5,7,9,1,0

// Элемент: 7
// Удвоенный элемент: 14
// Индекс: 1
// Массив: 5,7,9,1,0

// Элемент: 9
// Удвоенный элемент: 18
// Индекс: 2
// Массив: 5,7,9,1,0

// Элемент: 1
// Удвоенный элемент: 2
// Индекс: 3
// Массив: 5,7,9,1,0

// Элемент: 0
// Удвоенный элемент: 0
// Индекс: 4
// Массив: 5,7,9,1,0

// То есть на каждой итерации в консоль мы получаем Элемент, удвоенный элемент, индекс, и весь массив. Весь массив постоянно повторяется и если он нам не нужен то его можно исключить.

// --- Метод find для массива и объектов:
console.log("--- Метод find для массива и объектов:")

let people = [
    {id: 1, name: "Ivan"},   /* индекс 0 */
    {id: 2, name: "Masha"},  /* индекс 1 */
    {id: 3, name: "Alex"},   /* индекс 2 */
    {id: 4, name: "Kate"}    /* индекс 3 */
] 
// ключ можно не заключать в кавычки если в нём одно слово
// такое строение объектов всплывает в подсказке когда набираешь find

let item_find = people.find(function(item) /* в анонимной функции используем только item */
{
    if(item.id==2) return item /* функция возвращает элемент */
})
console.log(item_find) // получили безымянный объект {id = 2, name: 'Masha'}
// item.id это мы сначала обращаемся к элементу массива, и так как элементы у нас это объекты, то ставим точку и пишем id что является ключом, получается "объект.ключ" через точку.

// --- Метод findIndex для массива:
console.log("--- Метод findIndex:")

let find_index = people.findIndex(function(item) /* в анонимной функции используем только item */
{
    if(item.id==2) return item /* теперь функция возвращает найденный элемент, но в переменной получаем индекс */
})
console.log(find_index)
// Получили "1"

// --- Метод filter для массива:
console.log("--- Метод filter:")
console.log("--- if(item.id==2):")

let filter1 = people.filter(function(item) {
    if(item.id==2) return item /* теперь функция возвращает найденный элемент, но в переменной получаем один или несколько массивов */
})
console.log(filter1)
// Получили раскрывающийся массив с одним объектом с индексом 0 (индекс в пределах нового массива, а не в пределах старого массива):
// 0:{id: 2, name: 'Masha'}

console.log("--- if(item.id<3):")

let filter2 = people.filter(function(item) {
    if(item.id<3) return item /* теперь функция возвращает найденные элементы, и в переменной получаем несколько массивов */
})
console.log(filter2)
// Получили раскрывающийся массив с 2-мя объектами с индексом 0 и 1:
// 0: {id: 1, name: 'Ivan'}
// 1: {id: 2, name: 'Masha'}

// С помощью метода find нельзя получить несколько элементов удовлетворяющим условиям, а с помощью filter - можно.

// --- Метод map для массива:

console.log("\n --- Метод map для массивов:") /* Это от англ. слова карта, как бы составляем карту */

let arr_for_map = [5, 7, 9, 1, 0]

let arr_new = arr_for_map.map(function(item, index)
{ return item*3 })
// В каждый элемент нового массива будет помещен оригинальный элемент умноженный на 3 

// В VSCode неиспользуемый элемент в функции помечается серым цветом, его можно удалить вручную

console.log(arr_new)
// Получили: (5) [15, 21, 27, 3, 0]
// Мы как бы составили новый массив методом создания карты на основе карты оригинального массива. При этом оригинальный массив не тронут


console.log("\n --- Решение задач для закрепления:")

console.log("\n --- Задача №1: Создать массив состоящий из четных чисел от 0 до 20")

let arr_task1 = [] // создали пустой массив, ошибок нет, ошибки будут только если назвать его уже используемым именем

for (let i=0; i<20; i+=2) 
/* используем название переменной i которая уже была использована, она используется временно и поэтому её можно повтороно много раз писать */
{
    arr_task1.push(i)
}
console.log(arr_task1)
// Получили раскрывающийся массив: (10) [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

console.log("\n --- Задача №2: Создать массив состоящий из убывающих чисел от 30 до 0 и должны делиться на 3 без остатка")

let arr_task2_1 = []

for (let i=30; i>0; i-=3) {
    arr_task2_1.push(i)
}
console.log(arr_task2_1)
// Получили раскрывающийся массив: (10) [30, 27, 24, 21, 18, 15, 12, 9, 6, 3]
// Это мы решили с учетом математики заранее зная что вот такие числа делятся.

// Решим эту же задачу с помощью проверки условия деления на 3 
let arr_task2_2 = []

for (let i=30; i>0; i--) { // перебираем каждое число с шагом 1 в сторону уменьшения
    if (i%3==0) { // если остаток от деления i на 3 равен нулю
        arr_task2_2.push(i)
    }
}
console.log(arr_task2_2)
// Получили (10) [30, 27, 24, 21, 18, 15, 12, 9, 6, 3]

console.log("\n --- Задача №3: Создать массив состоящий из элементов в диапазоне 0-10, каждый из которых равен квадрату его индекса")

let arr_task3 = []

for (let i=0; i<10; i++) {
    arr_task3.push(Math.pow(i,2)) // Математическая функция Math.pow(число, степень). Число = переменная i, степень 2. Можно было написать i*i по самому простому методу.
}
console.log(arr_task3)
// Получили: (10) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

console.log("\n --- Задача №4: Найти количество четных элементов в массиве")

let arr_task4 = [7,4,2,1,0,6,2,6,2,15,4,16,20]
console.log(arr_task4)

// Метод 1, через for of:

let even = 0 // even - англ. четный
for (let item of arr_task4) {
    if (item%2==0) {even++}
}
console.log(`Количество четных элементов = ${even}`)
// Получили: 10

// Метод 2, через for:

let even2 = 0
for (i=0; i<arr_task4.length; i++) {
    if (arr_task4[i]%2==0) {even2++}
}
console.log(`Количество четных элементов = ${even2}`)
// Получили: 10

// Контрольные вопросы:

// В соответствии с синтаксисом укажите правильный тип цикла.

// ? (let k in obj) { }
// ? (i>10) { }
// ? (let i=0; i<10; i++) { }

// Ответ:
// for (let k in obj) { }
// while (i>10) { }
// for (let i=0; i<10; i++) { }

// --- 9.8 Функции + практика

function printText () {
    console.log(`Hello`)
}
// printText - это название функции
// В консоли мы ничего не видем потому что сама по себе функция ничего не делает пока мы её не вызовем.

printText() // Вызвали функцию, получили в консоли "Hello"
// В данном случае в скобках ничего нет, но там могут быть разные параметры

function printText2 (name, age) { // 2 параметра (name, age) в круглых скобках, существуют временно только в пределах функции, могут совпадать с ранее определенными
    console.log("Hello My name is " + name + ", Age: " + age)
}
printText2()
// Получили: Hello My name is undefined, Age: undefined
// Это потому что эти переменные не существуют. Чтобы они были нужно при вызове функции в скобках передать значения.

printText2("Евген", 39) 
// Получили : Hello My name is Евген, Age: 39
// Здесь "Евген" идет как первый параметр функции "name", 39 идет как второй параметр "age"
// Евген должен быть в кавычках, иначе получаем "Uncaught ReferenceError: Евген is not defined"

// Достоинство функций в том, что их можно вызывать хоть сколько раз с разными переменными:
printText2("Petr", 15) // Hello My name is Petr, Age: 15
printText2("Ivan", 17) // Hello My name is Ivan, Age: 17
printText2("Kate", 11) // Hello My name is Kate, Age: 11
printText2("Maria", 18) // Hello My name is Maria, Age: 18
// Получили 4 разных результата в консоли потому что 4 раза вызывали с разными параметрами 

// Вместо строк и чисел в качестве параметров можно вставлять заранее определённые переменные:

let name2_1 = "Евген3"
let age2_1 = 339
printText2(name2_1, age2_1) // Hello My name is Евген3, Age: 339

// Та же функция, но через возврат return:

function printText4 (name, age) { 
    return "Hello My name is " + name + ", Age: " + age
}

let name4 = "Евген4"
let age4 = 44
printText4(name4, age4) // В консоли ничего не появилось потому что функция вернула результат, но его нужно или присвоить переменной, или можно сразу вывести в консоль:

console.log(printText4(name4, age4)) // Hello My name is Евген4, Age: 44

// alert (printText3(name4, age4)) появилось всплывающее окно

let result = printText4("Евген5", 45)
console.log(result) // Hello My name is Евген5, Age: 45

// Вывод результата функции лучше делать не внутри функции, а снаружи как в примерах выше console.log(название функции) и alert(название функции), лобо записать результат функции в переменную а дальше выводит куда хотим и использовать как хотим.

console.log("\n --- Методы объекта")
// --- Метод объекта - это функция которая находится внутри объекта, и применяется в основном для действий с этим объектом:

let obj3 = {
    name: "Ivan",
    age: 28,
    hello () { // создали функцию с названием hello, при этом function писать не надо
        console.log(`Меня зовут ${this.name}`) // с помощью this. мы можем обратиться к ключу внутри объекта в котором находимся, причем результатом будет значение этого ключа, но будет результат только если вызвать этот метод отдельным кодом. this.name как бы говорит "этот объект.name"
    },
}

obj3.hello() // Это мы обратились к методу внутри объекта
// Получили в консоли: Меня зовут Ivan

console.log(obj3.age) // получили 28

// * Метод sort - сортировка массива
console.log("\n --- Метод sort - сортировка массива")

let arr_for_sort1 = [1,5,2,25,16,14,49,3,1,7]

console.log("\n let arr_for_sort1 = " + arr_for_sort1)

arr_for_sort1.sort(function(a,b){
    if (a==b) return 0
    if (a>b) return 1 // тут можно возвращать любое положительное число больше нуля
    if (a<b) return -1 // или любое отрицательное число
})
// В метод sort необходимо вставить анонимную функцию, которая позволит этому методу работать так как задумано. Без этой функции он работать не будет. Метод sort универсальный, и именно эта анонимная функция говорит методу как нужно сортировать.

// Этот метод берет 2 соседних числа, они идут как a и b и сравнивает их по нашим условиям, 0 = ничего не делать, +1 = переставить местами, -1 - ничего не делать, и так он проходится по каждой паре передвигаясь по шагу на 1 элемент.

console.log("сортировка длинным методом: " + arr_for_sort1)
// Получили отсортированный измененный массив (оригинал изменяется): 
// (10) [1, 1, 2, 3, 5, 7, 14, 16, 25, 49]

// Эту сортировку можно написать короче специальным выражением:
let arr_for_sort2 = [1,5,2,25,16,14,49,3,1,7]
arr_for_sort2.sort(function(a,b){
    return a-b
})
console.log("сортировка коротким методом .sort(function(a,b){return a-b}: " + arr_for_sort2)
// сортировка коротким методом: 1,1,2,3,5,7,14,16,25,49

// Ещё короче можно написать - через стрелочную функцию, которая во всплывающей подсказке:
let arr_for_sort3 = [1,5,2,25,16,14,49,3,1,7]
arr_for_sort3.sort((a, b) => a - b) 
console.log("сортировка стрелочной функцией .sort((a, b) => a - b): " + arr_for_sort3)
// Получили: 1,1,2,3,5,7,14,16,25,49

// Ещё один вариант записи - с фигурными скобками и return'ом:
let arr_for_sort4 = [1,5,2,25,16,14,49,3,1,7]
arr_for_sort4.sort((a, b) => {return a - b})
console.log("сортировка стрелочной функцией .sort((a, b) => {return a - b}): " + arr_for_sort4)
// Получили: 1,1,2,3,5,7,14,16,25,49
// Эти методы нужно запомнить, они сложные с заранее установленными функциями которые что-то возвращают.

// ! Существует ещё метод toSorted, который не сортирует оригинал - не изменяет оригинальный массив.

console.log(`\n --- Задача №1. Числа Фибоначчи (https://ru.wikipedia.org/wiki/Числа_Фибоначчи)`)

function fibonachi(count) // count - количество чисел, которые мы хотим видеть в последовательности
 {
    let fib = []
    for (let i=0; i<count; i++) {
        if (i==0) fib[i]=1
        else if (i==1) fib[i]=2
        else fib[i] = fib[i-2]+fib[i-1]
    }
    return fib // Возвращаем массив, он уже будет с числами. Если это не написать, получим undefined. В функции мы производим вычисление массива, который там высчитывается локально временно в оперативной памяти, а с помощью return мы вынимаем матрицу наружу и при вызове fibonachi(count) получим рассчитанный массив    
}
let f10 = fibonachi(10)
console.log(f10)
// Получили: (10) [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
// Они совпрадают с рядом который в Википедии


console.log(`\n --- Задача №2. Факториал (https://ru.wikipedia.org/wiki/Факториал)`)

function factorial(n) {
    let fact = 1 // сразу устанавливаем факториал 1 так как даже если число 0 будет, то результат хоть как будте 1
    if (n==0) return fact
    for(let i=1; i<=n; i++) { // начинаем с 1 спецально чтобы не получилось умножение на ноль, тем более условие n=0 мы уже описали выше
        fact*=i // эквивалентно fact=fact*i
    }
    return fact
}

let fact0 = 0
console.log(`factorial(fact0) = ${factorial(fact0)}`) // 1

let fact3 = 3
console.log(`factorial(fact3) = ${factorial(fact3)}`) // 6

let fact5 = 5
console.log(`factorial(fact5) = ${factorial(fact5)}`) // 120

let fact8 = 8
console.log(`factorial(fact8) = ${factorial(fact8)}`) // 40320
// все результаты совпадают с википедией

console.log(`\n --- Задача №3. Функция, которая получает какое-то число многозначное, и будет выводить сумму и произведение его отдельных цифр`)

let addAndMull = function (num) { // Это второй вариант записи функии. Это то ж самое если написать function addAndMull (num) {}
    num += "" // прибавили пустую строку к встроенной переменной чтобы превратить числовой тип(кот. по умолчанию) в строковый тип, то есть чтобы число превратить в строку с текстом числа. Это даст возможность пройтись по строке как по массиву
    let add = 0, mul = 1 // так можно писать - объявление в одну строку через запятую
    // в переменной add будет накапливаться сумма (англ. Add - прибавлять), а в mul - произведение (англ. multiply - умножать) и чтобы оно заработало изначально делаем равным 1
    for (let i = 0; i<num.length; i++) { // это мы проходим по числу как по массиву из цифр
        add += +num[i] // Накапливаем в add сумму из цифр. Чтобы математически суммирвалось, а не контагенировались цифры, нужно написать +num[i] что означает превратить строку в число (см. строка 311)
        mul *= num[i] // произведение можно не преобразовывать в число
    }
    return { 
        "Сумма": add,
        "Произведение": mul 
    }
    // фигурные скобки - чтобы в ворачиваемом можно было написать как будто объект
}
console.log(addAndMull(795))
// Получили раскрывающийся объект: {Сумма: 21, Произведение: 315}

console.log(`\n --- Задача №4. Необходимо перевернуть число, синвертировать все цифры`)

function reverse(number) {
    number += "" // превратили число в строку
    let reverseNumber = "" // создали пустую строку куда будем записывать результат
    for (let i=number.length-1; i>=0; i--) { // в цикле идём с конца в начало
        reverseNumber += number[i] // обе переменных сейчас имеют тип строка и поэтому будут контагенироваться
    }
    return +reverseNumber // добаляем плюс чтобы вернуть число, а не строку 
}
console.log(reverse(3486)) // получили 6843

console.log(`\n --- Задача №5. Необходимо подсчитать количество четных и нечетных цифр в числе`)

function chet_nechet(number) {
    number += ""
    let chet = 0, nechet = 0
    for (i=0; i<number.length; i++) {
        if (number[i]%2 == 0) chet++
        else nechet++
    } 
    return {
        "Число = ": number,
        "Кол-во четных цифр = ": chet,
        "Кол-во нечетных цифр = ": nechet
    }
}
console.log(chet_nechet(3486))
// Получили: {"Число = ": '3486', "Кол-во четных цифр = ": 3, "Кол-во нечетных цифр = ": 1}

console.log(`\n --- Задача №6. Функция угадывания числа от 0 до 100, количество попыток: 10`)

function randomNumber() {
    let random_number = Math.floor(Math.random()*100) // При каждом новом запуске функции генерируется новое рандомное число. Умножаем рандом на 100 и тогда случайное число будет не 0-1, а 0-100, затем его округляем мат-флуром
    for (let attempt=1; attempt<=10; attempt++) { // 10 попыток
        let user_number = +prompt(`Попытка № ${attempt}, Введите число:`) // +prompt означает превращаем введенную пользователем строку в число
        if (user_number == random_number) {
            return alert (`Вы угадали число! Попыток: ${attempt}, Число: ${user_number}`)
            // ретёрн завершит и цикл и вдобавок всю функцию, причем так, что ретёрн в самом низу не сработает
        } else if (user_number < random_number) {alert(`Ваше число ${user_number} меньше загаданного`)} // обязательно без return потому что он завершит цикл, а просто алерт даст, что вылезет окно после закрытия которого цикл повторяется и вылазиет промпт с запросом нового числа
        else if (user_number > random_number) {alert(`Ваше число ${user_number} больше загаданного`)}
        
        // else return alert (`Вы не угадали число. Загаданное число было: ${random_number}`) // эта строка не сработает в самом конце если не угадали число, потому что сработало одно из других условий, выносим её за цикл for
    }
    return alert (`Вы не угадали число. Загаданное число было: ${random_number}`)
    // этот return вне цикла, он завершает функцию. Как только цикл отработает 10 раз исполнится этот код
}

// randomNumber()
// Здесь не нужно console.log потому что функция работает сама по себе и выводит всё во всплывающих окнах.

// Вопрос: Как создать функцию на JavaScript?
// Ответ: function

// --- 9.9 Дата и время
console.log(`--- 9.9 Дата и время`)

let date_now = new Date () // Без аргументов. Создали новый объект класса Date с текущей датой и временем. Это из ООП который мы ещё не изучали)
console.log(date_now)
// Получили Wed Jan 17 2024 15:45:01 GMT+0700 (GMT+07:00)
// И при каждом перезапуске страницы эта дата меняется на текущую которая на компе.

let d60000 = new Date (60000) // Это 60 секунд
console.log(d60000)
// Получили: Thu Jan 01 1970 07:01:00 GMT+0700 (GMT+07:00)
// Если в качестве параметра пишем число, то это количество миллисекунд (1/1000 секунды), прошедших с 1 января 1970 года GMT+0. 1 минута это 60 000 миллисекунд, 1000 миллисекунд = 1 секунда. 60 секунд = 1 минута. Это целое число называется Timestamp (англ. штамп времени, отметка времени)
// Это время отсчета с полуночи по пролептическому всемирному координированному времени (UTC) 1 января 1970 года, не считая високосных секунд. Это - дата начала отсчета времени для компьютеров Unix, и эта временная метка помечена как "0"

let d50000 = new Date (50000) // 50 секунд
console.log(d50000)
// Получили: Thu Jan 01 1970 07:00:50 GMT+0700 (GMT+07:00)
// Это 50 секунд

// Указание даты и времени в кавычках:
let d_1 = new Date ("2015-01-08T10:51:08.941")
console.log(d_1)
// Год нужно указывать 4-мя цифрами
// месяц и день нужно указывать 2-мя цифрами. 
// T - это для разделения даты и времени. От англ. Time.
// если необходимо, то ставим точку и указываем 3-значное количество миллисекунд вплоть до 999 (потому что 1000 это 1 секунда)
// Получили: Thu Jan 08 2015 10:51:08 GMT+0600 (GMT+07:00)
// Миллисекунды не отображаются в консоли, но их можно потом извлечь из переменной
// В такой форме записи Январь это 01, декабрь 12.

// Метод Date.parse (parse англ. - разбор, синтаксический разбор, анализ):
console.log(Date.parse("2015-01-08T10:51:08.941"))
// Получили: 1420692668941
// Это - количество миллисекунд с 1970 года до даты которую мы указали

// Указание даты и времени через запятую:

let d_2 = new Date (2015, 6, 21, 10, 51, 54, 458)
console.log(d_2)
// Tue Jul 21 2015 10:51:54 GMT+0600 (GMT+07:00)
// 6 это июнь, но у нас получился июль который должен быть 7 месяцем по счету. Это потому что в такой форме записи месяца начинаются с нуля.
// Здесь обязательными являются только год и месяц, первые 2 числа, остальные не обязательны

// Введём только обязательные год и месяц
let d_3 = new Date (2015, 6)
console.log(d_3) 
// Получили: Wed Jul 01 2015 00:00:00 GMT+0600 (GMT+07:00)
// Получили год 2015, месяц Июль из-за того что отсчет с 0, день 1 выставилось само по умолчанию, время - по нулям.

// Методы для получения компонентов даты:

let d_4 = new Date (2015, 6, 21, 10, 51, 54, 458)

// Метод getFullYear() - получить год (4 цифры):
let d4_year = d_4.getFullYear() // без скобок не работает
console.log(d4_year) // Получили: 2015

// Метод getMonth() - получить месяц от 0 (январь) до 11 (декабрь)
let d4_month = d_4.getMonth()
console.log(d4_month) // Получили: 6 - это июль по отсчету от нуля (хотя по нормальному 06 это июнь)

// Для даты записанной с помощью "":
let d1_month = d_1.getMonth()
console.log(d1_month) // Получили: 0 - это январь по отсчету от нуля, причем в записи написано "2015-01-08T10:51:08.941"

// Метод getDate() - получить день месяца от 1 до 31. И никаких отсчетов от 0 нету тут. Не совсем логичное название, но его нужно запомнить:
let d4_day = d_4.getDate()
console.log(d4_day) // Получили: 21

// Метод getDay() - получить день недели от 0 (Воскресенье) до 6 (суббота)
let d4_day2 = d_4.getDay()
console.log(d4_day2) // Получили: 2 - это должен быть вторник Tue
// Отсчет начинается с нуля с воскресенья
// Язык как-то сам вычисляет день недели по своему внутреннему календарю высчитывая с 1970 года

// Метод getHours() - получить часы
let d4_hours = d_4.getHours()
console.log(d4_hours) // Получили: 10

// Метод getMilliseconds() - получить миллисекунды (которые мы не видели в консоли)
let d4_msec = d_4.getMilliseconds()
console.log(d4_msec) // Получили: 458

// 3 метода получения timestamp:

// 1) Метод getTime() - получить миллисекунды. Для заданной даты возвращает Timestamp 
let d4_timestamp = d_4.getTime()
console.log(d4_timestamp) // Получили: 1437454314458

// 2) Date.parse для той же даты:
let d4_dateParse = Date.parse(d_4)
console.log(d4_dateParse) // Получили: 1437454314000 (не хватает 458 миллисекунд)

// 3) + перед датой
let d4_plus = +d_4 // + (плюс) преобразует дату в Timestamp
console.log(d4_plus) // Получили 1437454314458

// Метод getTimezoneOffset() - возвращает разницу в минутах между местным временем и UTC. Англ. Offset - смещение, сдвиг, отклонение
let d4_timezone = d_4.getTimezoneOffset()
console.log(d4_timezone) // Получили: -360

// -- Установка компонентов даты:
// У методов в названии вместо get (англ. получить) пишется set (англ. установить)  
// Существует 8 методов установки года, часов, секунд и миллисекунд и т.д.

console.log(d_4) // Tue Jul 21 2015 10:51:54 GMT+0600 (GMT+07:00)

// Метод setHours(кол. часов) - установка количества часов у существующей даты
d_4.setHours(20)
console.log(d_4) // Tue Jul 21 2015 20:51:54 GMT+0600 (GMT+07:00)
// В итоге в дате было 10 часов, после метода стало 20

// Метод setTime() - устанавливает дату в виде целого количества миллисекунд, устанавливает общий timestamp заменяя всю дату на новую:
d_4.setTime(50000)
console.log(`d_4.setTime(50000)`)
console.log(d_4) // Thu Jan 01 1970 07:00:50 GMT+0700 (GMT+07:00)

console.log(d_4.getTime()) // Получили: 50000

// Все их рассматривать не будем, всё есть в подсказке

// Так можно получать даты ранее 1970 года:
// const d = new Date(-x);

// Автоисправление неправильных дат:

let d_5 = new Date (2016,1,30) // Указали 30 февраля 2016, но в этом феврале всего 29 дней. 

console.log(d_5) 
// Получили: Tue Mar 01 2016 00:00:00 GMT+0600 (GMT+07:00)
// Вместо 30 февраля вывелось 1 марта. Это автоматическое выправление даты в большую сторону на 1 день вперед. Если указать 31 февравля, то получим 2 марта - это на 2 несуществующих дня вперед

let d_6 = new Date (2016,1,28)

d_6.setDate(d_6.getDate()+4) // Установили день месяца на основе получения текущего дня месяца

console.log(d_6)
// Thu Mar 03 2016 00:00:00 GMT+0600 (GMT+07:00)
// Если посчитать, то 28+4 это 32 февраля, но такой даты нет, поэтому язык не выдал ошибку, а пересчитал дату как положено последовательно: 29 февраля, 1, 2, 3 марта

console.log(+d_6) // Получили: 1456941600000
// + (плюс) преобразует дату в Timestamp

// -- Измерение скорости кода:
// Использование разницы миллисекунд для измерения скорости выполнения фрагмента кода:

let start1 = + new Date () // + (плюс) даст преобразование даты в число Timestamp

for (let i=1; i<=10; i++) { // сделать кол циклов 10000 для замеров
    console.log(0)
}

let end1 = + new Date ()

let circle_time1 = end1 - start1
console.log(circle_time1)
// Получили: 610 на слабом компе. И ещё 0 и рядом 1000, это означает 0 вывелось в консоль 1000 раз 
// В итоге время выплнения цикла заняло 31 миллисекунд
// При этом каждый раз число меняется - 31, 15, 17 ... это видимо зависит от занятости процессора или еще от чего, например в первый раз этот цикл выполняется или повторно, если повторно то он почему-то выполняется в 2 раза быстрее судя по миллисекундам
// Но это - самодельный метод. Для таких целей существует специальный метод Date.now()

// Если нужно просто измерить время, объект Date нам не нужен. И тогда лучше использовать специальный метод Date.now(), возвращающий текущую метку времени
// Семантически он эквивалентен new Date().getTime(), однако метод не создаёт промежуточный объект Date. Так что этот способ работает быстрее и не нагружает сборщик мусора.

// Данный метод используется из соображений удобства или когда важно быстродействие, например, при разработке игр на JavaScript или других специализированных приложений.

// Метод Date.now():

let start2 = Date.now()  

for (let i=1; i<=10; i++) { // сделать кол. циклов 10000 для замеров
    console.log(0)
}

let end2 = Date.now()

let circle_time2 = end2 - start2
console.log(circle_time2)
// Получили: 846 - это ещё дольше почему-то

// -- Форматирование и вывод дат:

let d_7 = new Date(2014,11,31,12,30,0)

console.log(d_7) 
// Wed Dec 31 2014 12:30:00 GMT+0600 (GMT+07:00)
// Выше это без локальных опций

// Метод toString() выводит дату целиком. Он из семейства предыдущего метода только без локализации:

console.log(d_7.toString())
// Wed Dec 31 2014 12:30:00 GMT+0600 (GMT+07:00)
// получили то же самое что и вывести просто d_7

// Метод date.toLocaleString(локаль,опции) позволяет указать какие параметры даты нужно вывести и ряд настроек вывода, после чего интерпритатор сам сформирует строку.


let options1 = { // название options1 можно делать каким угодно
    era: "long", // Anno Domini, от Рождества Христова
    year: "numeric",
    month: "long", // December, декабря
    day: "numeric",
    weekday: "long", // Wednesday, среда
    timezone: "UTC",
    hour: "numeric",
    minute: "numeric",
    second: "numeric",
} // Эти опции можно удалять, изменять параметры, в итоге получим такую дату как нам требуется

console.log(d_7.toLocaleString("ru", options1))
// Получили: среда, 31 декабря 2014 г. от Рождества Христова в 12:30:00

console.log(d_7.toLocaleString("en-US", options1))
// Получили: Wednesday, December 31, 2014 Anno Domini at 12:30:00 PM
// Anno Domini (сокращенно AD) - дословно "Лето Господне".
// Для нас AD - "наша эра".

// Так же существует удобная бибилиотека moment.js (https://momentjs.com/) для работы с датами

// Метод toDateString() выводит только дату:
console.log(d_7.toDateString())
// Wed Dec 31 2014 без времени

// Метод toTimeString() выводит только время:
console.log(d_7.toTimeString())
// 12:30:00 GMT+0600 (GMT+07:00) без даты

// Вопрос
// Сопоставьте значения из двух списков
// getDate - "получить день месяца" (28 число например)
// getDay - "получить день недели" (например воскресенье 0)
// setMinutes - "установить минуты"
// getMonth - "получить месяц" (например январь 0)

// --- 9.10 JSDoc и Исключения

// Ниже это новый вид комментариев. Появляеся после /** и enter.
// Описание параметра функции начинается с @param, потом в фигурных скобках {string} задаем тип переменной

/** 
 * Функция преобразует строку с временем в минуты
 *  @param {string} time время в виде строки, например "02:08". Может быть в диапазоне от "00:00" до "23:59".
 *  @return {number} целое число в минутах. Например time="02:08" вернет 128.
 */
function timeToMinute (time) { // При наведении на функцию подсказка "(time:any: void)" в которой "time: any" означает любой тип данных, ":void" означает что функция ничего не возвращает (пока). После прописывания @param {string} time получилось "(time:string: void)", то есть теперь не любой тип, а именно string (там может быть number, boolean). После добавления @return {number} получаем в подсказке "(time:string: number)": вместо void появился number что означает что вернется число. 
    try {
        let hour = +time.split(":")[0] // Получили: 2 потому что мы указали + и сконвертировали в число. Если плюс не ставить, то получим "02", и это будет строка
        let minute = +time.split(":")[1]
          if ( !(hour>=0 && hour<=23) || !(minute>=0 && minute<=59)) {// поставили восклицательный знак ! -  это знак отрицания, для того чтобы проверить, что наши значения введены неправильно, || это ИЛИ что означает что одно любое из условий страбатывает и будет ошибка или в часах или в минутах
          throw new RangeError("Аргумент должен быть в формате 'hh:mm' - 'hh' должен быть от 0 до 23, а 'mm' должен быть от 0 до 59. 'hh' и 'mm' должны быть числами и разделяться знаком ':' ")
          } // здесь генерируем ошибку типа RangeError так как у нас ошибка в диапазоне значений
          return hour*60+minute
        } catch(error) {
            console.log(error) // Текст написанный для объяснения ошибки будет написан в консоли, не будет никаких всплывающих окон
        }
}
// Плюс (+) означает преобразование в число
// .split(":")[0] означает разделить на массив элементов, в качестве разделителя ":", [0] означает что взять из масcива элемент с индексом [0]. Если + и [0] не указать, то получим массив  "(2) ['02', '08']""

console.log(timeToMinute("02:08"))
// Получили: 128  
// При наведении курсора на имя функции появляется подсказка. Эта функция может быть где-то далеко либо даже в другом файле, а при таком описании нам сразу видно её документацию записанную в /** */. И станвится понятно что функция делает и как она работает, какие есть параметры, какого они типа. И что вернётся после return. 

// @param и @return этого более чем достаточно чтобы описывать свои функции для того чтобы удобно было работать и одному и в команде разработчиков. Но существует еще дополнительные параметры описания.

console.log(timeToMinute("24:08"))
// Получили в консоли: 
// RangeError: Аргумент должен быть в формате 'hh:mm' - 'hh' должен быть от 0 до 23, а 'mm' должен быть от 0 до 59. 'hh' и 'mm' должны быть числами и разделяться знаком ':' 
// at timeToMinute (main.js:1709:17)
// at main.js:1725:13
// undefined                           main.js:1725 undefined


// Объяснение try..catch:
// Неважно, насколько мы хороши в программировании, иногда наши скрипты содержат ошибки.
// Обычно скрипт в случае ошибки «падает» (сразу же останавливается), с выводом ошибки в консоль.
// Если закомментировать try..catch в нашей функции, то в строке 1725 вместо undefined получим 1422 (в данном это не ошибка и код не останавливается), но бывают случаи когда код не выполняется дальше вообще
// Но есть синтаксическая конструкция try..catch, которая позволяет «ловить» ошибки и вместо падения делать что-то более осмысленное.
// Работает она так:
// Сначала выполняется код внутри блока try {...}.
// Если в нём нет ошибок, то блок catch(err) игнорируется: выполнение доходит до конца try и потом далее, полностью пропуская catch.
// Если же в нём возникает ошибка, то выполнение try прерывается, игнорировать остаток try, и поток управления переходит в начало catch(err). Переменная err (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.


// Вопрос:
// Заполните пропуски таким образом, чтобы функция принимала и возвращала имя пользователя в строчном формате
// /**
// * @param {string} name тут указывается имя пользователя
// * @return {string} возвращаемое значение
// */

// -- Дополнительная литература:
// 1) 
// Генератор документации JSDoc https://ru.wikipedia.org/wiki/JSDoc . Здесь описаны дополнительные параметры

// 2)
// Библиотека stringTime.js для работы с временем в строковом формате
// https://github.com/morphIsmail/stringTimeJS
// Автор Исмаил Хусейнов 

// 3) 
// Обработка ошибок на JavaScript
// https://learn.javascript.ru/try-catch


// --- 9.11 ООП ----------------------------------------------------------------------------------------
console.log(`\n --- 9.11 ООП`);

let user = {
    name: "Ivan",
    age: 20,
}

console.log(user);
// Получили: {name: 'Ivan', age: 20} который можно развернуть:
// age: 20
// name: "Ivan"
// [[Prototype]]: Object (разворачивающийся список)
// -- constructor: ƒ Object() (разворачивающийся список)
// -- toString: ƒ toString()(разворачивающийся список)
// -- valueOf: ƒ valueOf() (разворачивающийся список)
// -- еще много пунктов

// Это означает следующее.
// Свойство proto есть у любого объекта и оно указывает на другой объект, который является родительским для данного.
// Когда мы разворачиваем proto, то видим набор разных методов. 
// Там мы видим буквы f, это функция. Но когда функция содержится внутри объекта, то она является методом данного объекта. 
// И таким образом наш объект user по умолчанию наследуется от стандартного объекта Object() и имеет дополнительные методы и доступ к ним, при этом мы эти методы сами не создавали.

// В нащем объекте попробуем вызвать метод toString() - это метод строкового преобразования
user.toString()
// В консоли ничего не появилось
// А вот если написать в консоли user.toString(), то видим '[object Object]' красным цветом

console.log(user.toString()); // Получили в консоли: [object Object]

// https://doka.guide/js/object-tostring/ Объекты, в отличие от примитивных типов, сложно преобразовывать в строку. Объект может содержать произвольное количество полей и без программиста непонятно, какие из них важные. Поэтому стандартная реализация метода toString() представляет собой заглушку и возвращает малоинформативную строку, например '[object Object]'. Этот метод нужно прописывать в объекте вручную чтобы он выводил то что надо https://learn.javascript.ru/object-conversion

// В нащем объекте попробуем вызвать метод valueOf() - это метод численного преобразования
user.valueOf()
// В консоли ничего не появилось
// А вот если написать в консоли user.valueOf(), то видим {name: 'Ivan', age: 20} красным цветом

console.log(user.valueOf()) // Получили в консоли: {name: 'Ivan', age: 20} это то же самое что и console.log(user)

// Эти 2 метода мы не создавали, но благодаря прототипу мы можем ими пользоваться.

let admin = {
    rules: 777,
    isAdmin() { // свойство-метод это обычная функция, но внутри какого-то объекта, и она позволяет делать что-то с его свойствами  
        console.log("Я админ " + this.name + ", мои права" + this.rules);
        // rules возьмётся из текущего объекта admin, name в данном объект нету, оно возьмется из дочернего объекта который унаследует текущий объект. Если написать console.log(admin.isAdmin()); то получим в консоли "Я админ undefined, мои права777"
    }
}

let user2 = {
    name: "Ivan",
    age: 20,
    __proto__: admin, // обязательно с 2-мя "_" слева и справа
}

console.log(user2);
// Получили:
// {name: 'Ivan', age: 20, _proto_: {…}} (разворачивающийся список)
// - age: 20
// - name: "Ivan"
// - [[Prototype]]: Object (разворачивающийся список)
// --- rules: 777 // это свойство видно уже в развернувшейся веладке, его сразу не видно пока не развернёшь. Здесь мы видим свойство rules, которое было унаследовано от нашего объекта admin, так как мы указали его в качестве прототипа для нашего объекта user
// --- isAdmin: ƒ isAdmin() // так же унаследовался метод isAdmin()
// 
// --- [[Prototype]]: Object (разворачивающийся список)
// Этот Prototype находится внутри в раскрывающемся списке [[Prototype]]: Object и значение имеет уже обычный стандартный Object 
// Это говорит нам о том, что хоть мы и изменили прототип объекта самостоятельно, мы все равно можем получить доступ по цепочке к самому верхнему нашему родительскому объекту

// user2.rules() // попытка выполнения этого приводит к ошибке Uncaught TypeError: user2.rules is not a function  потому что это не метод, а ключ объекта, или его ещё называют свойством

console.log(user2.rules);
// Получаем 777 в консоли. Если console.log не написать, то в консоли ничего не видно. Хотя в нашем объекте такого свойства не было, мы его получили от родителя.

console.log(user2.toString());
// Получили [object Object]. Это мы проверили что так же до сих пор работает метод самого основного нашего родителя, который является прототипом для всех объектов, и мы так же можем получить к нему доступ.

// ПРИНЦИП НАСЛЕДОВАНИЯ это следующее: Таким образом можно создать какой-то один комплексный объект, и потом создаём другие объекты и указываем в качестве прототипа наш большой родительский объект. И все дочерние объекты смогут иметь доступ к его свойствам и методам.

// Далее рассмотрим пример когда нам надо создавать много объектов по типу user.

// Далее ниже функция-конструктор:
function User (name,age) { // имена функций конструкторов делаем с Большой буквы - это специально чтобы различать простые функции от конструкторов. Она будет работать и с маленькй буквы, но это принятое соглашение для удобства. Так будет удобно и нам и людям которые будут с нами работать
    this.name = name // с помощью "this." мы можем указать, что хотим установить для этого объекта какое-то свойство, например name, и устанавливаем его равным его нашему параметру name который первый в скобках выше и который мы сами будем передавать. Если this не указывать, то получаем name = name и в консоли видим что это свойство вообще не установилось и отсутсвует. Мы же в объекте к ключу обращаемся через точку, this. и служит чтобы к этому объекту с помощью точки присвоить свойство. Так же это this присутсвовало в методах у объекта.
    this.myInfo = function() { // для конструктора используется отличная от простого объекта конструкция
        console.log("Меня зовут "+this.name+", мне "+ this.age + " лет");
    }
    this.age = age // значение age получаем из параметров метода (в скобках, второе значение после запятой), которое мы сами будем передавать
    this.__proto__ = admin // в качестве прототипа указываем объект admin, это обязательно должен быть именно объект, иначе ничего работать не будет. В итоге каждый объект, который мы будем создавать с помощью этого конструктора, будет наследоваться от объекта admin
}

// В новой переменной создадим объект с помощью функции-конструктора
let u1 = new User ("Petr", 21) // слово new это специальное слово, с помощью которого мы можем создать новый объект с помощью конструктора. Если new не написать, получаем в консоли main.js:1857 Uncaught TypeError: 
// Слово User это название конструктора
// В скобках мы передаём значения в качестве параметров name,age

console.log(u1);
// Получили: User {name: 'Petr', age: 21, myInfo: ƒ}
// А если раскрыть объект, то увидим дополнительную 4-ю строку [[Prototype]]: Object в которой находится isAdmin: ƒ isAdmin() и rules:777 
// Мы видим что u1 это объект у которого написано с большой буквы User, потому что мы создавали его по конструктору User
// В итоге имеем всю цепочку наследования до самого глобального объекта

// Теперь попробуем создать несколько объектов с помощью нашего конструктора:

let u2 = new User ("Kate", 38)
console.log(u2);
// Получили: User {name: 'Kate', age: 38, myInfo: ƒ}

let u3 = new User ("Masha", 39)
console.log(u3);
// Получили: User {name: 'Masha', age: 39, myInfo: ƒ}

// new User это: new = ключевое слово - команда создать новый объект на основе конструктора, User = название конструктора

// В итоге получили 3 объекта u1, u2, u3 у которых в названием фигурирует конструктор User и у каждого есть свои значения name, age, myInfo и так же каждый наследуется от admin и они по сути являются admin'ами.

// Как видно с помощью прототипов __proto__ можно наследовать какие-то свойства и методы от родительского объекта. А с помощью функции-конструктора можно создавать много однотипых объектов очень простым образом вместо того чтобы вручную создавать объекты и  разные значения им указывать. Там мы делали для даты с помощью функции-конструктора Date - создавали много объектов даты с разными значениями и у нас создаются объекты для разных даты и времени.

// Используем метод первого корневого объекта admin на основе которого сделан конструктор User. Но это работает только для объектов уже созданных предварительно (u1, u2, u3).
u1.isAdmin()
// Получили в консоли: Я админ Petr, мои права777

u2.isAdmin()
// Получили: Я админ Kate, мои права777

u3.isAdmin()
// Получили: Я админ Masha, мои права777

// С помощью прототипов мы связываем один объект с другим. В результате можно использовать комбинацию свойств и методов нескольких объектов.

// Так же можно указать объект модератор или гостевой пользователь, и у них указать свои свойства, права им изменить, и тем самым сделать несколько конструкторов с помощью которых можно будет делать разные объекты и в дальнейшем использовать все их свойства,методы, и те которые есть у их прототипов.  

// Используем метод-функцию конструктора User:
u1.myInfo()
// Получили: Меня зовут Petr, мне 21 лет

u2.myInfo()
// Получили: Меня зовут Kate, мне 38 лет

u3.myInfo()
// Получили: Меня зовут Masha, мне 39 лет

// --- Классы: ---------------------------------------------------------------------------------------------------------
console.log("\n --- Классы:");

// Класс - это шаблон кода, который позволяет нам легко создавать объекты

class UserClass { // Имя не должно совпадать с именем Конструктора
    admin = true // В классе не надо писать this. пишем как будто в обычном объекте находимся 
    constructor (name, age) { // Используем ключевое слово constructor и в скобках переменные - это если нам нужно обрабатывать вводимые извне переменные. Сам constructor() является методом, как будто это  myInfo () который ниже. Здесь уже надо писать this.
        this.name = name
        this.age = age
    } // , здесь могkа быть запятая как в объекте которая бы разделяла методы, но в классе этого не нужно делать. Можно точку с запятой ";" но ни в коем случае не просто запятую 
        myInfo () { // для класса используется создание метода как для обычного объекта. В constructor его нет необходимости помещать так как он не использует воодимые данные извне
            console.log("Меня зовут "+this.name+", мне "+ this.age + " лет")}
            // Если засунуть этот метод в constructor, то получаем Uncaught SyntaxError: Unexpected token '{' (at main.js:1916:19) и полный обвал JS-кода в консоли
} 

let u11 = new UserClass ("Petr", 21)
console.log(u11);
// Получили: раскрывающийся UserClass в котром: UserClass {admin: true, name: 'Petr', age: 21}
// при этом myInfo() можно увидеть только если открыть раскрывающийся [[Prototype]]:Object

let u12 = new UserClass ("Kate", 19)
console.log(u12);
// Получили: UserClass {admin: true, name: 'Kate', age: 19}

let u13 = new UserClass ("Masha", 20)
console.log(u13);
// Получили: UserClass {admin: true, name: 'Masha', age: 20}

// Класс - это разновидность функции. Свойства берутся как есть, затем из тела конструктора берется тело, но все методы представляются в виде наследования - их не видно сразу, они помещаются в прототипы.

console.log("\n class UserClass2 :");

class UserClass2 { 
    constructor (name, age, admin=false ) { // admin=false означает, что по умолчанию подставляется false
        this.name = name
        this.age = age
        this.admin = admin // ключ admin должен брыться из параметров конструктора, если не укажем это 3-е значение, то присвоится false
    } 
        myInfo () { 
            console.log("Меня зовут "+this.name+", мой возраст: "+ this.age)
            if (this.admin == true) {
                console.log("Я админ");
            }
        }
}

let u21 = new UserClass2 ("Petr", 21)
console.log(u21);
// Получили: UserClass2 {name: 'Petr', age: 21, admin: false}
// 3-ий параметр не указали, поэтому получили admin: false = класс по умолчанию присвоил admin=false

u21.myInfo()
// Меня зовут Petr, мой возраст: 21



let u22 = new UserClass2 ("Kate", 19, true)
console.log(u22);
// Получили: UserClass2 {name: 'Kate', age: 19, admin: true}

u22.myInfo()
// Меня зовут Kate, мой возраст: 19
// Я админ



let u23 = new UserClass2 ("Masha", 20)
console.log(u23);
// Получили: UserClass2 {name: 'Masha', age: 20, admin: false}


console.log("\n class Moderator extends UserClass2");
class Moderator extends UserClass2 { 
    addPost() {
        console.log("New Post");
    }
    myInfo () { // Если мы хотим изменить метод в дочернем классе, в нашем случае метод myInfo (), то мы его заново указываем, и он теперь будет работать как собственный метод вместо/поверх такого же метода в UserClass2
        console.log("Меня зовут "+this.name+", мой возраст: "+ this.age)
        if (this.admin == true) {
            console.log("Я модератор"); // Вместо "Я админ" получим "Я модератор"
        }
    }
}
// extends UserClass2 означает, что class Moderator наследуется от UserClass2
// У модератора нет своего конструктора, но так как конструктор есть у UserClass2, то у него есть точно такой же конструктор
// В итоге у модератора будут все те же свойства и методы, которые были у UserClass2

let m1 = new Moderator("Ivan", 22, true)

console.log(m1);
// Получили: Moderator {name: 'Ivan', age: 22, admin: true}

m1.myInfo()
// Меня зовут Ivan, мой возраст: 22
// Я модератор

m1.addPost()
// New Post

console.log("\n Переопределение метода в классе:");

class Moderator2 extends UserClass2 { 
    addPost() {
        console.log("New Post");
    }
    myInfo () { 
        super.myInfo() // Если мы хотим существующий метод не изменить, а выполнить и еще что-то дополнить, то выполняем с помощью ключевого слова super. В итоге выполнится метод myInfo() от родителя, 
        console.log("Я модератор"); // После выполнения родительского метода myInfo() мы дополняем его текущей строкой
        }
}

let m2 = new Moderator2("Ivan", 22, true)

m2.myInfo()
// Меня зовут Ivan, мой возраст: 22
// Я админ
// Я модератор
// В итоге мы выполнили сначала родительский метод, а потом дополнили его своими действиями (добавился вывод в консоль "Я модератор")
// Выглядит странно, но для того чтобы наглядно показать как это работает - самое то.

console.log("\n Переопределение конструктора в классе:");

class Moderator3 extends UserClass2 { 
    constructor (name, age, admin=false, moder=true) { // добавли ", moder=true"
        super (name, age, admin /* =false */ ) // всё что в скобках скопировали из оригинального конструктора, только из admin=false надо убрать false иначе всегда будем получать false даже если руками ввели true
        // this.name = name
        // this.age = age
        // this.admin = admin // исключили эти 3 строки так как они есть в родительском конструкторе
        this.moder = moder // добавили новое свойство
    } 
// Если не написать вызов super родительского конструктора, и попытаться объявить переменную на основе этого класса, то получим ошибку:
// Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
//   at new Moderator3 (main.js:2032:9)
//   at main.js:2046:10
    static addPost() { // дописали перед этим методом static, после чего он перестанер работать для переменных
        console.log("New Post");
    }

    static master = true // дописали новое статическое свойство 

    myInfo () { 
        super.myInfo() 
        console.log("Я модератор");
        }
}

let m3 = new Moderator3("Ivan", 22, true, false)
console.log(m3);
// Получили раскрывающийся объект: Moderator3 {name: 'Ivan', age: 22, admin: true, moder: false}

let m4 = new Moderator3("Ivan", 22) // по умолчанию должны присвоиться admin=false, moder=true
console.log(m4);
// Получили раскрывающийся объект: Moderator3 {name: 'Ivan', age: 22, admin: false, moder: true}

// m3.addPost()
// Получили Uncaught TypeError: m3.addPost is not a function    at main.js:2059:4
// Это потому что напсиали static и теперь такой метод недоступен у конкретного объекта, но доступен у самого класса.

Moderator3.addPost()
// Получили: New Post        main.js:2043
// Из-за static метод доступен только у самого класса.

// То есть статические методы позволяют делать что-то не с конкретным объектом, а в общем какой-то функционал который доступен из класса.
// Это похоже на библиотеку Math.sqrt(), у которой есть свои методы и они делают что-то конкретное. Math это класс, и через точку можно вызвать какие-то его методы. Вот примерно такой же аналог мы сейчас создали с помошью статического метода в виде класса Moderator3.

console.log(Moderator3.master); // так как это свойство обвчное, то круглых скобок не надо
// Получили: true

// console.log(m4.master)
// Получили: undefined потому что это свойство статическое, и у переменных, которые делаются на основе класса, оно отсутствует
// Так же как и методы, стаические свойства работают с самим классом, а не с его дочерними объектами. И это так же может быть полезно и можно использовать в определенных ситуациях

// --- Практика с классами:
// К классам можно писать документацию JSDoc

class People {
    /**
     * Класс человек 
     * @param {String} fio по формату "Фамилия Имя Отчество"
     * @param {String} birthday день рождения по формату "24.11.1984"
     * @param {String} numbers "номер", если больше 2 номеров, то по формату "номер1, номер2"
     * @param {Number} room комната
     */
    constructor(fio, birthday, numbers="", room="") { // конструктор создается для того, чтобы было удобно создавать объекты на основе класса. numbers="", room="" сделали по умолчанию пустыми, этим мы сделали их не обязательными для ввода, если мы их не введём, то подставится пустая строка
        let name = fio.toLowerCase().split(" ") // делаем маленькими буквами и разделяем на массив по пробелу
        this.name = {} // Создали пустой объект для имени (не массив!)
        this.name.f = name[0][0].toUpperCase() + name[0].slice(1) // В первом слове, первую букву делаем большой, затем прибавляем из первого слова оставшиеся буквы начиная с 1-го индекса
        this.name.i = name[1][0].toUpperCase() + name[1].slice(1)
        this.name.o = name[2][0].toUpperCase() + name[2].slice(1)
        // В итоге мы фамилию имя и отчество привели в нормальный вид и с помощью точки (.) поместили по отдельности как свойства объекта name
        
        let date = birthday.split(".") // разделили на массив по точке
        this.date = {}
        this.date.d = +date[0] // + для преобразования из строки в число. День
        this.date.m = +date[1] // месяц
        this.date.y = +date[2] // год
        
        // Телефоны:
        this.numbers = numbers.split(", ")

        // Телефоны, способ №2 дурацкий:
        // let phone = number.split(", ")
        // this.numbers = [] // создали переменную хранящую номера телефонов в виде массива, а не объектом, потому что номера телефонов нам удобнее будет хранить просто под индексами
        // for(let i = 0; i<phone.length; i++) {
            // this.numbers.push(phone[i])  }

        this.room = +room
    } // конец конструктора

    static month = ["января", "февраля", "марта", "апреля", "мая", "июня", "июля", "августа", "сентября", "октября", "ноября", "декабря"]; // Это - статическое свойство для класса, это месяца в массиве в правильном склонении
    
    /**
     * Вывести ФИО
     * @return {String} Строка формата "Фамилия Имя Отчество"
     */
    getFio() { // Создадим собственный метод для вывода ФИО
        return `${this.name.f} ${this.name.i} ${this.name.o}`
    }

    /**
     * Вывести день рождения
     * @return {String} Строка формата "24 июля 1997"
     */
    getBirthday () {
        return `${this.date.d} ${People.month[this.date.m-1]} ${this.date.y}` // People.month: Статическое свойство указывается с предварительным указанием названия класса без всяких this.month[] и просто month[] которые дают ошибку
    }

    /**
     * Вывести Фамилия Имя Отчество.расширение 
     * @param {String} extension расширение, например "jpg" или "png"
     * @return {String} для названия изображения
     */
    getImgSrc(extension) {
        return `${this.name.f}_${this.name.i}_${this.name.o}.${extension}` // Если напишем extension без ${}, то получим слово, а не переменную
    }

    /**
     * Вывести все номера телефона или только первый номер
     * @param {Boolean} allNumbers если true то все номера, если false - только первый номер
     * @return {String} Строка формата: "89006660099, 89009996699"
     */
    getNumberList(allNumbers) {
        if (this.numbers.length == 0 || this.numbers[0].length == 0) 
            return undefined
        // { 
            // return console.log(`undefined + this.numbers= ${this.numbers}, this.numbers.length=${this.numbers.length}, this.numbers[0].length = ${this.numbers[0].length}`);
        // }

        if (allNumbers) { // условие allNumbers=true не обязательно писать, можно просто allNumbers что воспринимается языком как true
            return this.numbers.join(", ") // объединяем через ", " и получим то же что было при входе: все номера склеятся через запятая-пробел. 
        } else {
            return this.numbers[0] // то есть если false, то получим только первый номер телефона из нескольких
        }
    }
}

let people1 = new People ("тЮтИкоВ Евгений Владимирович", "25.11.1984", "9984, 8847, 5478", 548)
console.log(people1);
// Получили:
// People {name: {…}, date: {…}, numbers: Array(3), room: 548}
// - разворачивающийся объект: date:{d: 25, m: 11, y: 1984}
// - разворачивающийся объект: name: {f: 'Тютиков', i: 'Евгений', o: 'Владимирович'}
// - разворачивающийся массив: numbers: (3) ['9984', '8847', '5478']
// - room: 548
// - [[Prototype]]: Object
// -- constructor: class People

console.log(people1.getFio());
// Получили: Тютиков Евгений Владимирович

let people2 = new People ("Иванов Иван иванович", "20.12.1984", "5487", 522)
console.log(people2); // Получили полный объект для Иванов Иван иванович
console.log(people2.getFio());
// Получили: Иванов Иван Иванович. Метод вернул уже исправленные конструктором класса ФИО

// В итоге видим что метод getFio() для каждого человека возвращает свой собственный результат

console.log(people1.getBirthday());
// Получили 25 ноября 1984

console.log(people2.getBirthday());
// Получили 20 декабря 1984

// В итоге мы пишем методы и они не просто выводят, а выполнив действи немного преобразовав

console.log(people1.getImgSrc("png")); // png нужно преедавать самостоятельно и обязательно в кавычках, иначе будет ошибка
// Получили: Тютиков_Евгений_Владимирович.png

console.log(people2.getImgSrc("pdf"));
// Получили: Иванов_Иван_Иванович.pdf

// И теперь для любого объекта мы можем получать изображение зная конкретный формат.

console.log(people1.getNumberList(true));
// Получили: 9984, 8847, 5478

console.log(people1.getNumberList());
// Получили: 9984

console.log(people2.getNumberList(true));
// Получили: 5487

let people3 = new People ("Иванов Иван иванович", "20.12.1984")
console.log(people3.getNumberList(true));
// Получили: undefined                  main.js:2211

// Попытка отловить получаемые значения (закомментированны)
// undefined + this.numbers= , this.numbers.length=1, this.numbers[0].length = 0     main.js:2151 (причем на строке класса это происходит)
// undefined main.js:2209 
// Если закомментировать условие при котором обрабатывается случай если телефоны вообще не введены, то получаем в консоли пустоту на строке main.js:2209


// Дополнительная литература:
// Статические свойства и методы:
// https://learn.javascript.ru/static-properties-methods

// Вопросы:
// Какое ключевое слово позволяет обратиться к своим полям и методам класса?
// Ответ: this

// --- 9.12 ECMAScript 2015 (ES6)
console.log("\n --- 9.12 ECMAScript 2015 (ES6)");

// https://babeljs.io/

// Создадим простенький класс на 6 строк
class A {
    a = 5 // пременная а имеет значение 5
    sum(b) { // метод который нао будет вызывать отдельно sum(b), который потребует ввод в скобки числа вернёт свойство а плюс b
        return this.a + b
    }
}
// Этот код написан на ECMAScript6
// Скопируем его в https://babeljs.io/ -> Try it out

// Получили справа в окне преобразованный код в скрипт предыдущего поколения ECMAScript5 как сказал Исмаил Хусейнов, но у меня стоит галочка React и результат отличный от его, результат следующий:
// function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
// function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// class A {
//   constructor() {
//     _defineProperty(this, "a", 5);
//   }
//   // пременная а имеет значение 5
//   sum(b) {
//     // метод который нао будет вызывать отдельно sum(b), который потребует ввод в скобки числа вернёт свойство а плюс b
//     return this.a + b;
//   }
// }

// В результате такой код длиньше, но зато он будет поддерживаться в большем количестве браузеров, получится максимальная поддержка в других браузерах и устрйоствах. 

//  --- Дополнительные возможноси, которые появились в стандарте ES6: ------------------------

// Ключевое слово const:
// С помощью let мы создавали переменную, которую потом изменяли. Если мы хотим создавть неизменяемую переменную, то используем const

const a_const = 3.5

console.log(a_const);
// Получили: 3.5

// a_const = 1
// Получили в консоли: Uncaught TypeError: Assignment to constant variable.    at main.js:2270:9
// Получили ошибку потому что это константа 
// const это константа и её никак нельзя изменять самостоятельно. Её можно указать 1 раз при создании с каким-то значением, и далее всегда она будет с таким значением.

// -- Оператор расширения (...):

function sum (a,b) { // Простенькая функция суммирования 2-х чисел
    return a+b
}
let arr_10 = [4,8] // создали массив в котором 2 числа
console.log(sum(...arr_10)); // вместо sum(4,8) или вместо sum(arr_10[0],arr_10[1]) пишем "...массив". 4 подставилось в качестве a, 8 подставилось в качестве b
// Получили: 12.

// Это - удобный способ передать массив с данными в функцию в качестве отдельных параметров
// Благодаря оператору русширения (...) массив разбивается на отдельные значения и подставляется в функцию в качестве аргументов
// Это уобно когда есть массив с данными и их нужно быстро передать в функцию

// -- Диструктивное присваивание[]:

// Например мы хотим создать несколько переменных и сразу присвоить им некоторые значения.

let [a4,b4,c4,d4] = [10,5,8,9]
// В итоге у нас создано 4 отдельные переменные (а не массив с ними), и мы их можем использовать по отдельности.

console.log(`a4=${a4}, b4=${b4}, c4=${c4}, d4=${d4}`);
// Получили: a4=10, b4=5, c4=8, d4=9

// Это называется деструктивное присваивание

// Вместо того, чтобы писать:
// let array = [10,5,8,9]
// let a4 = array[0]
// let b4 = array[1] ...
// Вместо этого мы быстро присваиваем нескольким переменным какие-то значения из массива

// -- Стрелочные функции

let sum_arrow = (a, b, c) => { // аналогично function sum_arrow ((a, b, c) {}
    return a+b+c
}

console.log(sum_arrow(5,2,3));
// Получили: 10

// Когда у нас после return всего одна строка, точнее одно выражение, то можно запись ещё сократить:

let sum_arrow2 = (a, b, c) => a+b+c

console.log(sum_arrow2(4,8,9));
// Получили: 21

// Функции позданные с помощью этого синтаксиса являются анонимными 
// Преимущество стрелочных функций перед обычными - это то что они сохраняют контекст. 

// Контекст функций:

// function Person() { // функция-конструктор Person
//     this.age = 0
//     setInterval (function grow() {
//         this.age++
//         console.log(this.age);
//     }, 1000)
// }

// var p = new Person()
// Получили: NaN и отсчет каждую 1 секунду слева

// Когда мы создаём функцию, то у неё с помощью слова this можно обратиться к её собственному контексту. Например мы указываем this.age = 0, и в пределах функции this.age будет в данном контексте. Но когда мы создаём здесь дополнительную функцию и указываем её в качестве анонимной функции для setInterval, который вызыввет какую-то функцию через 1000 миллисекунд, и в этой внутренней функции мы хотим увеличить this.age на единицу и вывести этот this.age

// Как результат, после запуска этого кода получаем какой-то непонятный результат - почему-то наш возраст не увеличивается и не выводится. Это потому что у этой функции grow которую мы создали свой собственный this. И получается this.age во внутренней функции grow это не тоже самое что this.age во внешней функции Person. Для такого случая и пригодится стрелочная функция

function Person() {
    this.age = 0
    setInterval (() => {
        this.age++
        console.log(this.age);
    }, 1000)
}

// var p = new Person() // Эта строка запускает отсчет в консоли. let p тоже работает
// Получили:  1 main.js:2346 и отсчет каждую 1 секунду слева

// И теперь this.age в функции Person и this.age в стрелочной функции это одно и то же стало.
// Это - самый простой пример на котором можно объяснить что такое контекст и как его сохранить с помощью стрелочных функций. И он заключается в демонстрации того, что у каждой функции свой this это что-то своё собственное. И для того чтобы внутри вложенных функций они совпадали, мы используем стрелочные функции. 
// Теперь понятно что стрелочные функции это не только способ более короткой записи функции, но и очень полезный механизм, который нужно использовать с умом в тех ситуациях, когда это действительно требуется. Можно сохранить констекст и наш код будет работать так как задуманно. 

// -- Создание двоичных чисел (бинарных чисел) the binary system of calculus (англ.) - двоичная система исчисления: ----------------

let a_bin = 0b0111 // 0b указывает, что это двоичное число, после чего пишем число в двоичном коде

console.log(a_bin);
// Получили в консоли: 7

// В результате мы получаем число в десятичной системе, но задаём его в двоичной форме. 

// -- Восьмиричная система. octal number system (англ.) - восьмеричная система счисления: -----

let b_oct = 0o10

console.log(b_oct);
// Получили: 8

// -- Проверка числа не целоcтность integer ---

// Целым числом называется чило, дробная часть которого равна нулю. А четное, это которе еще и на 2 делится.

// В JScript все числа представлены в виде чисел с плавающей запятой? даже если написать 18.0 это считается целочисленным числом как будто у него нет плавающей точки

// Есть метод isInteger для выяснения что это за число

console.log(Number.isInteger(18.0)); // Number это класс
// Получили: true это потому что после запятой у нас ничего нет

console.log(Number.isInteger(18.1)); 
// Получили: false и это означает что число не целое

console.log(Number.isInteger(17)); 
// Получили: true потому что нет плавающей запятой


// --- Функция isNaN - NaN = not a number ----------------
console.log("\n IsNaN:");
// Сначала рассмотрим старый код, а потом новый аналог из ES6
// Существует специальное значение NaN, с помощью которого можно проверять, что это не число.
// Старая функция isNaN возвращает нам false только в том случае если у нас число, а еслли у нас NaN то true, и самое сранное, если NaN в виде надписи в кавычках, то тоже true, если любое слово в кавычкаъ, то опять true.

let a10 = "NaN" // старый метод говорит что это - не число NaN, это true, это NaN
let b10 = NaN // Метод возвращает что это true, это NaN. Метод работает не совсем точно, нам нужно чтобы только здесь было true, нужно точное сравнение с NaN 
let c10 = "hello" // старый метод говорит что это - не число NaN, это true, это NaN
let d10 = 12 // старый метод говорит что это число, не NaN, это false
console.log(isNaN(a10)); // true
console.log(isNaN(b10)); // true
console.log(isNaN(c10)); // true
console.log(isNaN(d10)); // false

// В ES6 появился новый метод - нужно у класса Number использовать метод isNaN: 
console.log("\n Number.isNaN:");
console.log(Number.isNaN(a10)); // false
console.log(Number.isNaN(b10)); // true
console.log(Number.isNaN(c10)); // false
console.log(Number.isNaN(d10)); // false
// В результате только поное совпрадение с NaN даёт true
// NaN применяется в функциях и алгоритмах с числами, различных математических рассчетах. 

// ---------------------------------------------------------------
console.log("\n --- Дополнительные тригонометрические методы ES6:");

console.log(Math.sinh(0));      // Получили: 0. Гиперболический синус
console.log(Math.cosh(0));      // Получили: 1. Гиперболический косинус
console.log(Math.tanh(0));      // Получили: 0. Гиперболический тангенс
console.log(Math.asinh(0));     // Получили: 0. Обратный гиперболический синус
console.log(Math.acosh(1));     // Получили: 0. Обратный гиперболический косинус
console.log(Math.atanh(0));     // Получили: 0. Обратный гиперболический тангенс
console.log(Math.hypot(2,2,1)); // Получили: 3. Теорема Пифагора

// ---------------------------------------------------------------
console.log("\n --- Дополнительные алгебраические методы ES6:");

console.log(Math.log2(16));    // Получили: 4. Логарифм по основанию 2
console.log(Math.log10(1000)); // Получили: 3. Логарифм по основанию 10
console.log(Math.log1p(0));    // Получили: 0. То же что и log(1+value)
console.log(Math.expm1(0));    // Получили: 0. Функция обратная Math.log1p()
console.log(Math.cbrt(8));     // Получили: 2. Корень кубический. Это как sqrt, только не квадратный корень, а кубический

// ---------------------------------------------------------------
console.log("\n --- Метод sign для определения знака числа:");

console.log(Math.sign(16)); // Получили: 1. Значит число положительное
console.log(Math.sign(-16)); // Получили: -1. Значит число отрицательное
console.log(Math.sign(0)); // Получили: 0. Значит число равно нулю

// ---------------------------------------------------------------
console.log("\n --- Методы для работы со строковыми типами данных:");


console.log("\n - Метод .repeat для повтора строки n-ое количество раз:");

console.log("Str".repeat(3)); // Получили StrStrStr

let str3 = "NewStr ".repeat(3)
console.log(str3) // Получили: NewStr NewStr NewStr 

// ---------------------------------------------------------------
console.log("\n - Метод .includes");

// Метод .includes применяется для поиска одной строки в другой:

let str31 = "Hello, i'm simple String"
console.log(str31.includes("simple")); // Получили: true. В скобках строка которую ищем 

// Возвращает true если есть совпадения, false - если нету. 

console.log(str31.includes("simple", 12)); // Получили: false. В скобках строка которую ищем, запятая и номер индекса с которого надо начинать искать, так как начало индекса дальше начала слова "simple", то получили false потому чот не нашли слово

// ---------------------------------------------------------------
console.log("\n - Методы .startsWith(), endsWith()");

console.log(str31.startsWith("Hello")) // Получили: true.
// Метод используется для выяснения начинается ли данная строка с определенной строки. Метод чувствителен к регистру. Можно через запятую указать номер индекса, с которого начать проверять

console.log(str31.endsWith("String")) // Получили: true.
// Метод позволяет нам проверить заканчивается ли строка на определенный текст

console.log(str31.endsWith("ing")) // // Получили: true.

// ---------------------------------------------------------------
console.log("\n - Метод .fill() для массива");

// Метод .fill() позволяет нам заполнять все значения массива необходимым значением 

let arr_fill = [5,8,9,2,4]
console.log(`arr_fill = ${arr_fill}`); // arr_fill = 5,8,9,2,4

// arr_fill.fill(0) // С помощью метода мы занеси в массив нули. В скобках указывается значение, которое хотим занести
console.log(`arr_fill = ${arr_fill}`); // arr_fill = 0,0,0,0,0
// В результате весь массив заполнился нулями

// Существуют ещё 2 параметра:  стартовый индекс и конечный

arr_fill.fill(0, 1, 5) // стартовый индекс заполнения 1, конечный индекс 3 не включительно, то есть только индексы 1 и 2.
console.log(`arr_fill = ${arr_fill}`); // arr_fill = 0,Заполнение,Заполнение,0,0

// Метод заполняет массив от № индекса и до № индекса не включительно.

// ---------------------------------------------------------------
console.log("\n - Методы .entries(), .keys(), values() для массива");

let arr_41 = ['a', 'b', 'c']
let entries = arr_41.entries()
let keys = arr_41.keys()
let values = arr_41.values()

console.log(entries); // Array Iterator {}
console.log(keys); // Array Iterator {}
console.log(values); // Array Iterator {}
// Если "..." не написать, то у нас получится непонятный Array Iterator {}. Чтобы посмотреть что получилось в этом ArrayIterator'e мы используем три точки

console.log(...entries); // Получили 3 горизонтально расположенных массива раскрывающихся (2) [0, 'a'] (2) [1, 'b'] (2) [2, 'c']. В каждом номер индекса и значение, и это всё в виде массивов
console.log(...keys); // Получили: 0 1 2. Возвращаются индексы 
console.log(...values); // Получили: a b c. Возвращаются значения

// ---------------------------------------------------------------
console.log("\n - Множества new Set()")

// Множества похожи на массив, но это строка с фигурными скобками вместо квадратных, и в них не могут повторяться элементы.
// Множество это вроде бы и не массив, и не объект, но реализуется он по таким технологиям, просто с ним удобнее работать в некоторых ситуациях.

let set = new Set()
set.add(1) // С помощью add мы добавляем значение
set.add(2)
set.add(5)
set.add(1) // Так как единица в множестве уже есть, то она не добавится второй раз
console.log(set); // Получили: Set(3) {1, 2, 5} в котором нет дубликатов
console.log(set.has("4")); // Получили: false. Метод has это проверка имеется ли элемент в этом множестве. Значения 4 нет, поэтому мы получили false 
console.log((set.size)); // Получили: 3. Метод size возвращает размер множества
set.delete(5) // Удалить элемент 5. Именно элемент с конкретным значением (не индекс)
console.log(set); // Получили: Set(2) {1, 2}
set.clear() // Метод clear очищает множество
console.log(set); // Получили: Set(0) {size: 0}. Множество очистилось

// Уловка: 
// Имеется массив с числами, в котором имеются дубликаты. Необходимо убрать дубликаты.

let arr_for_set = [1,5,4,7,8,91,1,4,5]
let arr_no_dubl = [...new Set (arr_for_set)]
// Такая конструкция позволяет удалить все дубликаты из массива.
// Мы сначала превращаем массив в множество, а затем с помощью трех точек и квадратных скобок превращаем наше множество обратно в массив так как нам в результате нужен именно массив, чтобы с ним раюотать как с обычнм массивом а не как с множеством. Три точки в начале квадратных скобок это команда заполнить массив получившимся множеством.

console.log(arr_no_dubl); // Получили: (6) [1, 5, 4, 7, 8, 91]. Получили масив без дубликатов.

// Если три точки и квадратные скобки убрать, то получим множество так же без дубликатов 
let arr_no_dubl2 = new Set (arr_for_set)
console.log(arr_no_dubl2); // Set(6) {1, 5, 4, 7, 8, …}
// Но с этим множеством нельзя работать теми методами, которые предназначены для массивов

// Вопрос:
// Какие методы мы рассмотрели в этом уроке?
// isNaN - Да 
// fill - Да
// add - Да
// keys - Да
// includes - Да

// ---------------------------------------------------------------
console.log("\n - 9.13 Задачи на JS, Часть 1")

// Общее по задачам:
// let a = Number(require('fs').readFileSync(0, 'utf8'))

// На платформе Stepik есть 3 окна: 
// 1) Первое большое окно для нашего кода. 
// 2) Второе маленькое с названием "Test input:" куда автоматически платформой записывается первое тестовое число/ строка. Мы можем вручную стелеть это число и напечатать любое своё число и нажать "Запустить код"
// 3) Третье "Test output:" это выходное окно после рассчетов, как console.log у нас

// Внутри слатформы есть какой-то файл куда записываются входные тестовые данные которые мы видим в окошке "Test input:"
// для взятия числа, надо написать let a = Number(require('fs').readFileSync(0, 'utf8')), такой текст обычно там уже по умолчанию. Number впереди сранной строки указывает на то что мы берём число. (require('fs').readFileSync(0, 'utf8')) означает что система Stepik берет данные с помощью синхронизации с фнутренним файлом, чтение идет в формате кодировки utf8
// для того чтобы взять от туда текстовую строку текста, надо удалить Number перед странной строкой, получится так: let a = (require('fs').readFileSync(0, 'utf8')), то есть 

// Sample Input 1: 4
// Sample Output 1: 16
// Эта запись означает, что входное значение для теста будет 4, затем платформа запустит наш код в котором есть "console.log(P)", который означает что результат нашего кода должен появиться в console.log, но появится в 3-ем окне "Test output:". Коротко говоря console.log(P) = "Test output:" в которое выведется значение P.

// ---------------------------------------------------------------
console.log("\n - Задача №1 (решено самим Stepik'ом как пример)")

// Дана сторона квадрата a. Найти его периметр P=4*a
// Категория: Ввод и вывод данных, оператор присваивания 
// Можно указать любое число, программа должна работать универсально

// Sample Input 1: 4    // Тест №1
// Sample Output 1: 16

// Sample Input 2: 5    // Тест №2
// Sample Output 2: 20

// Sample Input 3: 3    // Тест №3
// Sample Output 3: 12

// Решение (верное):
// let a = Number(require('fs').readFileSync(0, 'utf8'))
// let P = 4 * a
// console.log(P)

console.log("\n - Задача №2 (решено самим Stepik'ом как пример)")
// Дана сторона квадрата a. Найти его периметр P=4*a
// Категория: Ввод и вывод данных, оператор присваивания 
// Можно указать любое число, программа должна работать универсально
// Sample Input 1:

// Sample Input 1: 5
// Sample Output 1: 20

// Sample Input 2: 6
// Sample Output 2: 24

// Sample Input 3: 3
// Sample Output 3: 12

// Sample Input 4: 4
// Sample Output 4: 16

// Sample Input 5: 7
// Sample Output 5: 28

// Решение (верное):
// process.stdin.resume();
// process.stdin.setEncoding("utf-8");
// var stdin_input = "";

// process.stdin.on("data", function (input) {
//     stdin_input += input;
// });

// process.stdin.on("end", function () {
//    main(stdin_input);
// });

// const main = (inp) => { // inp это входное тестовое число
//    const P = inp*4 // это формула для рассчета P 
//    return console.log(P);
// };

console.log("\n - Задача №3 (есть жирная подсказка в задании)")

// Дана сторона квадрата a. Найти его площадь S=a^2
// Категория: Ввод и вывод данных, оператор присваивания
// Подсказка:
// Возвести число в квадрат можно умножив его на себя или воспользовавшись функцией pow, которая возводит указанное число в любую степень
// let S = Math.pow(a, 2)
// Так же в некоторых языках программирования существует специальный оператор возведения числа в степень
// let S = a ** 2

// Sample Input 1: 3
// Sample Output 1: 9

// Sample Input 2: 2
// Sample Output 2: 4

// Sample Input 3: 1
// Sample Output 3: 1

// Sample Input 4: 4
// Sample Output 4: 16

// Sample Input 5: 0
// Sample Output 5: 0

// Решение:
// let a = Number(require('fs').readFileSync(0, 'utf8'))
// let S = Math.pow(a, 2)
// console.log(S)

console.log("\n - Задача №4")

// Дано расстояние L в сантиметрах. Используя операцию деления нацело, найти количество полных метров в нем (1 метр = 100 см)
// Категория: Целые числа
// Подсказка:

// let L = 299 // в 299 сантиметрах только 2 полных метра
// let M = L / 100 // в ходе деления получится дробное число, в данном примере 2,99
// let result = Math.trunc(M) // Math.trunc отбрасывает дробную часть числа, в результате останется 2 (для данного примера)

// Sample Input 1: 299
// Sample Output 1: 2

// Sample Input 2: 101
// Sample Output 2: 1

// Sample Input 3: 54
// Sample Output 3: 0

// Решение:
// let L = Number(require('fs').readFileSync(0, 'utf8'))

// let M = L / 100 // в ходе деления получится дробное число, в например 2,99 при входном тестовом значении 299 см
// let result = Math.trunc(M) // Math.trunc отбрасывает дробную часть числа, в результате останется 2 (для данного примера)
// console.log(result)


console.log("\n - Задача №5")
// Дано целое число A. Проверить истинность высказывания: «Число A является положительным»
// Категория: Логические выражения

// Sample Input 1: 10
// Sample Output 1: true

// Sample Input 2: 0
// Sample Output 2: false

// Sample Input 3: -6
// Sample Output 3: false

// Решение (моё, верное):
// let A = Number(require('fs').readFileSync(0, 'utf8'))
// let positive = undefined
// if (Math.sign(A) > 0) {
//     positive=true
//     } else {
//     positive=false
//     }
// console.log(positive)

console.log("\n - Задача №6")

// Даны два целых числа: A, B. Проверить истинность высказывания: «Справедливы неравенства A > 2 и B ≤ 3»

// Категория: Логические выражения

// Входные данные всегда передаются в виде строки. Если требуется передать два входных параметра, то мы передаем их в одной строке через пробел в той последовательности как указано в условиях задачи.

// Например, Вход: 5 10 означает что A=5, B=10

// let data = require('fs').readFileSync(0, 'utf8') // сейчас data="5 10" - это строка
// let data = require('fs').readFileSync(0, 'utf8').split(" ") // разделяет строку на массив строк, в таком случае data=['5', '10'] - массив строк, элемент под индексом 0 это строка 5 - не число!, data[1]='10'
// let A = +data[0], B = +data[1] // унарный плюс превращает строку из элементов массива в число
// // теперь в переменной A число 5, в переменной B число 10. УЖЕ НЕ СТРОКИ, А ЧИСЛА!
// console.log(A > 2 && B <=3) // и далее работаем с этими числами A и B так как угодно и решаем задачу выводя результат в консоль

// Sample Input 1: 1 2
// Sample Output 1: false

// Sample Input 2: 2 3
// Sample Output 2: false

// Sample Input 3: 3 4
// Sample Output 3: false

// Sample Input 4: 4 3
// Sample Output 4: true

// Sample Input 5: 5 2
// Sample Output 5: true

// Решение:
// let data = require('fs').readFileSync(0, 'utf8').split(" ")
// let A = +data[0], B = +data[1]
// console.log(A > 2 && B <=3)

console.log("\n - Задача №7")
// Дано целое число. Если оно является положительным, то прибавить к нему 1; в противном случае не изменять его. Вывести полученное число
// Категория: Условный оператор
// Подсказка:
// n++ так можно увеличить число на 1 (инкрементировать его), работает во многих языках программирования
// можно указать и по другому, например: n = n + 1 или n += 1 или ++n

// Sample Input 1: 53
// Sample Output 1: 54

// Sample Input 2: 0
// Sample Output 2: 0

// Sample Input 3: -6
// Sample Output 3: -6

// Sample Input 4: 1
// Sample Output 4: 2

// Решение:
// let n = Number(require('fs').readFileSync(0, 'utf8'))
// if (n>0) {n++}
// console.log (n)

console.log("\n - Задача №8")
// Даны три целых числа. Найти количество положительных и количество отрицательных чисел в исходном наборе
// Категория: Условный оператор

// Sample Input 1: 8 11 0
// Sample Output 1: Положительных чисел: 2, Отрицательных чисел: 0

// Sample Input 2: 5 3 -5
// Sample Output 2: Положительных чисел: 2, Отрицательных чисел: 1

// Sample Input 3: -3 0 1
// Sample Output 3: Положительных чисел: 1, Отрицательных чисел: 1

// Решение:
// let data = require('fs').readFileSync(0, 'utf8').split(" ")
// let a = +data[0], b = +data[1], c = +data[2]
// let positive = 0, negative = 0
// if (a>0) positive++ 
// if (a<0) negative++
// if (b>0) positive++ 
// if (b<0) negative++
// if (c>0) positive++ 
// if (c<0) negative++
// console.log(`Положительных чисел: ${positive}, Отрицательных чисел: ${negative}`)

console.log("\n - Задача №9")
// Дано целое число в диапазоне 1–7. Вывести строку — название дня недели, соответствующее данному числу (1 — «Понедельник», 2 — «Вторник» и т. д., для других чисел вывести значение - «Неизвестно»)
// Категория: Оператор выбора

// Sample Input 1: 1
// Sample Output 1: Понедельник

// Sample Input 2: 2
// Sample Output 2: Вторник

// Sample Input 3: 3
// Sample Output 3: Среда

// Sample Input 4: 4
// Sample Output 4: Четверг

// Sample Input 5: 5
// Sample Output 5: Пятница

// Sample Input 6: 6
// Sample Output 6: Суббота

// Sample Input 7: 7
// Sample Output 7: Воскресенье

// Sample Input 8: 0
// Sample Output 8: Неизвестно

// Sample Input 9: 8
// Sample Output 9: Неизвестно

// Sample Input 10: -1
// Sample Output 10: Неизвестно

// Решение:
// let day = Number(require('fs').readFileSync(0, 'utf8'))
// let day_arr = ["Неизвестно", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье"] // "" обязательны, иначе ошибка
// if (day >0 && day<=7) {
// console.log(day_arr[day])
// } else {console.log(day_arr[0])}

console.log("\n - Задача №10")
// Даны целые числа K и N. Вывести N раз число K
// Категория: Цикл с параметром

// Sample Input 1: -5 4
// Sample Output 1: -5-5-5-5

// Sample Input 2: 3 0
// Sample Output 2: Ошибка

// Sample Input 3: 0 1
// Sample Output 3: 0

// Sample Input 4: 2 3
// Sample Output 4: 222

// Sample Input 5: 6 -1
// Sample Output 5: Ошибка

// Решение:
// let data = require('fs').readFileSync(0, 'utf8').split(" ")
// let K=+data[0], N=+data[1]
// if (N>0) { 
//     console.log(`${K}`.repeat(N)) 
// } else console.log("Ошибка")

console.log("\n - Задача №11")
// Даны положительные числа A и B (A >= B). На отрезке длины A размещено максимально возможное количество отрезков длины B (без наложений). Не используя операции умножения и деления, найти длину незанятой части отрезка A.

// Нужно использовать цикл while

// Категория: Цикл с условием

// Sample Input 1: 11 3
// Sample Output 1: Длина незанятой части отрезка A: 2

// Sample Input 2: 7 2
// Sample Output 2: Длина незанятой части отрезка A: 1

// Sample Input 3: 3 3
// Sample Output 3: Длина незанятой части отрезка A: 0

// Sample Input 4: 1 3
// Sample Output 4: Ошибка

// Решение:
// let data = require('fs').readFileSync(0, 'utf8').split(" ")
// let A=+data[0], B=+data[1]
// if (A>=B) {
//     let nezanato = A
//     while (nezanato>=B) {
//         nezanato-=B
//     }
//     console.log(`Длина незанятой части отрезка A: ${nezanato}`)
// } else console.log("Ошибка")

console.log("\n - Задача №12")

// Дано целое число K. Вывести строку-описание оценки, соответствующей числу K (1 — «Плохо», 2 — «Неудовлетворительно», 3 — «Удовлетворительно», 4 — «Хорошо», 5 — «Отлично»). Если K не лежит в диапазоне 1–5, то вывести строку «Ошибка»
// Категория: Оператор выбора

// Sample Input 1: 1
// Sample Output 1: Плохо

// Sample Input 2: 2
// Sample Output 2: Неудовлетворительно

// Sample Input 3: 3
// Sample Output 3: Удовлетворительно

// Sample Input 4: 4
// Sample Output 4: Хорошо

// Sample Input 5: 5
// Sample Output 5: Отлично

// Sample Input 6: 0
// Sample Output 6: Ошибка

// let K = Number(require('fs').readFileSync(0, 'utf8'))
// if (K>=1 && K<=5) {
//      let ozenka = {1: 'Плохо', 2: 'Неудовлетворительно', 3: 'Удовлетворительно', 4: 'Хорошо', 5: 'Отлично'};
//      console.log(ozenka[K])
// } else console.log("Ошибка")

console.log("\n - Задача №13")

// Даны два целых числа A и B. Вывести в порядке возрастания все целые числа, расположенные между A и B (включая сами числа A и B), а также количество N этих чисел
// Категория: Цикл с параметром

// Sample Input 1: 2 4
// Sample Output 1:
// 2
// 3
// 4
// Всего чисел: 3

// Sample Input 2: 1 3
// Sample Output 2:
// 1
// 2
// 3
// Всего чисел: 3

// Sample Input 3: 4 1
// Sample Output 3:
// Ошибка

// Решение:
// let data = require('fs').readFileSync(0, 'utf8').split(" ")
// let A = +data[0], B = +data[1]
// if (A<=B) {
//     kolichestvo = 0
//     for (i=A; i<=B; i++) {
//     console.log(i)
//     kolichestvo++
//     }
//     console.log(`Всего чисел: ${kolichestvo}`)
// } else console.log("Ошибка")

console.log("\n - Задача №13")
// Дано целое число. Если оно является положительным, то прибавить к нему 1; в противном случае вычесть из него 2. Вывести полученное число
// Категория: Условный оператор

// Sample Input 1: 1
// Sample Output 1: 2

// Sample Input 2: 0
// Sample Output 2: -2

// Sample Input 3: -3
// Sample Output 3: -5

// Решение:
// let d = Number(require('fs').readFileSync(0, 'utf8'))
// let result = d
// if (d>0) result+=1
// else result-=2
// console.log(result)

console.log("\n - 9.14 Задачи на JS, Часть 2")

console.log("\n - Задача №14")
// Дано целое число A. Проверить истинность высказывания: «Число A является нечетным»
// Категория: Логические выражения

// Sample Input 1: 8
// Sample Output 1: false

// Sample Input 2: -5
// Sample Output 2: true

// Sample Input 3: 3
// Sample Output 3: true

// Sample Input 4: 0
// Sample Output 4: false

// Решение:
// let A = Number(require('fs').readFileSync(0, 'utf8'))
// console.log(A%2 == 0 ? false : true)

console.log("\n - Задача №15")

// Дана масса M в килограммах. Используя операцию деления нацело, найти количество полных тонн в ней (1 тонна = 1000 кг)
// Категория: Целые числа

// Sample Input 1: 25001
// Sample Output 1: 25

// Sample Input 2: 6999
// Sample Output 2: 6

// Sample Input 3: -5800
// Sample Output 3: Число должно быть больше чем 0

// Sample Input 4: 0
// Sample Output 4: Число должно быть больше чем 0

// Решение:
// let K = Number(require('fs').readFileSync(0, 'utf8'))
// console.log(K>0 ? Math.floor(K/1000) : "Число должно быть больше чем 0")

console.log("\n - Задача №16")

// Даны стороны прямоугольника a и b. Найти его площадь S=a*b и периметр P=2*(a+b)
// Категория: Ввод и вывод данных, оператор присваивания

// Sample Input 1: 5 8
// Sample Output 1:
// S = 40
// P = 26

// Sample Input 2: 3 4
// Sample Output 2:
// S = 12
// P = 14

// Sample Input 3: 1 3
// Sample Output 3:
// S = 3
// P = 8

// Решение:
// let data = require('fs').readFileSync(0, 'utf8').split(" ")
// let A = +data[0], B = +data[1]
// let S = A*B // Площадь прямоугольника
// let P = 2*(A+B) // Периметр прямоугольника
// console.log("S = " + S)
// console.log("P = " + P)

console.log("\n - Задача №16")

// Дан размер файла в байтах. Используя операцию деления нацело, найти количество полных килобайтов, которые занимает данный файл (1 килобайт = 1024 байта)
// Категория: Целые числа

// Sample Input 1: 7000
// Sample Output 1: 6

// Sample Input 2: 2048
// Sample Output 2: 2

// Sample Input 3: 4096
// Sample Output 3: 4

// Решение:
// let b = Number(require('fs').readFileSync(0, 'utf8'))
// console.log(Math.trunc(b/1024))

// Доп. арианты решения: 

// console.log(~~(b/1024)) символ ~~() аналогичен Math.trunc() - убирает дробную часть

// console.log(Math.floor(b / 1024))  можно и так, округление в нижнюю сторону

console.log("\n - Задача №17")

// Дано целое число A. Проверить истинность высказывания: «Число A является четным»
// Категория: Логические выражения

// Sample Input 1: 6
// Sample Output 1: true

// Sample Input 2: 0
// Sample Output 2: true

// Sample Input 3: -3
// Sample Output 3: false

// Sample Input 4: -6
// Sample Output 4: true

// Sample Input 5: 3
// Sample Output 5: false

// Sample Input 6: 8
// Sample Output 6: true

// Решение:
// let A = Number(require('fs').readFileSync(0, 'utf8'))
// if (A%2 == 0) even=true
// else even=false
// console.log(even)

// Доп. арианты решения: 

// console.log(A % 2 == 0)

// let result = A % 2;
// console.log(result === 0); 

console.log("\n - Задача №18")

// Даны десять вещественных чисел. Найти их сумму
// Категория: Последовательности

// Sample Input 1: 9 5 1 4 14 2 0 6 32 111
// Sample Output 1: 184

// Sample Input 2: 0 0 0 1 1 1 1 0 2 2
// Sample Output 2: 8

// Sample Input 3: -5 0 -2 4 3 1 -7 0 2 1
// Sample Output 3: -3

// Решение:
// let A = require('fs').readFileSync(0, 'utf8').split(' ') // split превращает строку в массив
// // console.log(A) // массив строк

// let numberArray = [] // пустой массив
// for (var i = 0; i < A.length; i++) {
//     numberArray.push(parseInt(A[i])) // преобразовать строку в число и добавить в новый массив
// }
// // console.log(numberArray) // на выходе получаем массив чисел, с ним уже можно работать

// let summa = 0
// for (let i=0; i<numberArray.length; i++) {
//     summa += numberArray[i]
// }
// console.log(summa)

// Другие ваианты:
// Метод массива reduce() https://doka.guide/js/array-reduce/
// let A = require('fs').readFileSync(0, 'utf8').split(' ') // split превращает строку в массив

// let numberArray = [] // пустой массив
// for (var i = 0; i < A.length; i++) {
//     numberArray.push(parseInt(A[i])) // преобразовать строку в число и добавить в новый массив
// }
// const sum = numberArray.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
// console.log(sum)

// Здесь 0 это начальное значение аккумулятора. accumulator это дополнительный аргумент — это текущее аккумулируемое значение.
// currentValue - элемент массива в текущей итерации
// Главной особенностью reduce(), которую важно запомнить, является наличие аккумулятора. Аккумулятор — это и есть то новое вычисляемое значение. Во время выполнения функции-колбэка нужно обязательно возвращать его значение, поскольку оно попадает в следующую итерацию, где будет использоваться для дальнейших вычислений. Мы можем представить аккумулятор как переменную, значение которой можно поменять в каждой новой итерации. С помощью второго аргумента в reduce() эта переменная получает своё начальное значение.
// Метод reduce() крайне полезен, когда мы хотим с помощью манипуляции значениями массива вычислить какое-то новое значение. Такую операцию называют агрегацией. Это мощный инструмент для обработки данных: например, его можно использовать для нахождения суммы величин в массиве или группировки в другие типы данных.

// Вариант for-of
// let sum = null;
// for (let numStr of A) {
//      sum += +numStr;
// }
// console.log(sum) 

// Высчитывание суммы сразу псле преобразования
// let A = require('fs').readFileSync(0, 'utf8').split(' ') // split превращает строку в массив
// let sum = 0

// let numberArray = [] // пустой массив
// for (var i = 0; i < A.length; i++) {
//     numberArray.push(parseInt(A[i])) // преобразовать строку в число и добавить в новый массив
//     sum += numberArray[i]
    
// }
// console.log(sum) // на выходе получаем массив чисел, с ним уже можно работать

// Без преобразования в новый массив:
// let A = require('fs').readFileSync(0, 'utf8').split(' ') // split превращает строку в массив
// let sum = 0 
// for(i of A){sum += +i} // плюс для преобразования в число
// console.log(sum)

console.log("\n - Задача №19")

// Описать процедуру PowerA3(A, B), вычисляющую третью степень (куб) числа A и возвращающую ее в переменной B (A — входной, B — выходной параметр; оба параметра являются вещественными). С помощью этой процедуры найти третьи степени пяти любых чисел
// Категория: Процедуры и функции

// Sample Input 1: 5 3 1 2 6
// Sample Output 1:
// Число 5 в кубе = 125
// Число 3 в кубе = 27
// Число 1 в кубе = 1
// Число 2 в кубе = 8
// Число 6 в кубе = 216

// Sample Input 2: 0 -3 3 4 12
// Sample Output 2:
// Число 0 в кубе = 0
// Число -3 в кубе = -27
// Число 3 в кубе = 27
// Число 4 в кубе = 64
// Число 12 в кубе = 1728

// Решение:
// let A = require('fs').readFileSync(0, 'utf8').split(' ') // split превращает строку в массив
// let numberArray = [] // пустой массив
// for (var i = 0; i < A.length; i++) {
//     numberArray.push(parseInt(A[i])) // преобразовать строку в число и добавить в новый массив
// } // на выходе получаем массив чисел, с ним уже можно работать
// function PowerA3(a) {
// return Math.pow(a,3)
// }

// for (let item of numberArray) {
// console.log(`Число ${item} в кубе = ${PowerA3(item)}`)
// }

// Вариант где в функции второй параметр становится результатом
// function PowerA3 (A,B){
//     B = Math.pow(A,3)
//     return B    
// }

// for (i=0;i<A.length;i++){
//     console.log(`Число ${A[i]} в кубе = ${PowerA3(A[i])}`)  // Но здесь в вызове функции мы не вводим параметр И. Что-то здесь не то  
// }

// Вариант
// let A = require('fs').readFileSync(0, 'utf8').split(' ') // split превращает строку в массив
// let numberArray = []
// for (var i = 0; i < A.length; i++) {
//     console.log(`Число ${A[i]} в кубе = ${power3(A[i])}`)
// } 

// function power3(A){
//     A = A**3 // две звездочки это возведение в степень
//     return A
// }

// Вариант без функции
// let A = require('fs').readFileSync(0, 'utf8').split(' ') // split превращает строку в массив
// let numberArray = [] // пустой массив
// for (var i = 0; i < A.length; i++) {
//     numberArray.push(parseInt(A[i])) // преобразовать строку в число и добавить в новый массив
//     console.log(`Число ${A[i]} в кубе = ${A[i]**3}`);
// } // на выходе получаем массив чисел, с ним уже можно работать

// Вариант стрелочная функция
// const powerA3 = (arr)=>{ // вместо arr мы подчтавим потом наш массив numberArray
//     for(let i of arr){
//     console.log(`Число ${i} в кубе = ${Math.pow(i, 3)}`);
//     }
// }
// powerA3(numberArray)

// Вариант метод forEach и стрелочная функция
// numberArray.forEach(i => console.log(`Число ${i} в кубе = ${Math.pow(i, 3)}`))

console.log("\n - Задача №20 Начиная отсюда начать читать чужие решения")

// Описать функцию CircleS(R), находящую площадь круга радиуса R. Площадь круга радиуса R вычисляется по формуле S=π*R^2. В качестве значения π использовать 3.14
// Категория: Процедуры и функции

// Sample Input 1: 3
// Sample Output 1: 28.26

// Sample Input 2: 5
// Sample Output 2: 78.5

// Sample Input 3: 6
// Sample Output 3: 113.04

// Решение:
// let r = Number(require('fs').readFileSync(0, 'utf8'))
// function CircleS(R) {
//     let S = 3.14*R**2 // **2 это возведение в степень 2
//     return S
// }
// console.log(CircleS(r))

