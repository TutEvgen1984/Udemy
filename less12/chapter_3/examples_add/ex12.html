<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../css/style.css">
  <title>Пример 12 - Экранирование, специальные символы</title>
</head>
<body>

  <script>
    // Статья: https://learn.javascript.ru/regexp-escaping
    // Как мы уже видели, обратная косая черта \ используется для обозначения классов символов, например \d. Это специальный символ в регулярных выражениях (как и в обычных строках).
    // Есть и другие специальные символы, которые имеют особое значение в регулярном выражении. Они используются для более сложных поисковых конструкций.
    // Вот полный перечень этих символов: [ ] \ ^ $ . | ? * + ( ).

    console.log("6.2".match(/\d\.\d/)); // ['6.2', index: 0, input: '6.2', groups: undefined]

    console.log("652".match(/\d\.\d/)); // null (не нашлось, это правильно)

    // точка без экранирования почему-то тоже работает:
    console.log("Текст 6......2 ещё текст".match(/\d......\d/)); // ['6......2', index: 6, input: 'Текст 6......2 ещё текст', groups: undefined]

    // ошибка кроется в следующем: если ввести 652 то есть вместо точки написать цифру, то оно у нас находится, такого не должно быть (это не правильно)
    console.log("Текст 652 ещё текст".match(/\d.\d/)); // ['652', index: 6, input: 'Текст 652 ещё текст', groups: undefined]

    // этот потому что точка (.) без экранирования соответствует поиску любого символа.
    // Но если мы её экранировать с помощью черты, то ищется именно точка

    // Косая черта
    //Символ косой черты '/', так называемый «слэш», не является специальным символом, но в JavaScript он используется для открытия и закрытия регулярного выражения: /...шаблон.../, поэтому мы должны экранировать его.
    // Вот как выглядит поиск самой косой черты '/':

    console.log("Текст / Текст 2".match(/\//));
    // ['/', index: 6, input: 'Текст / Текст 2', groups: undefined]

    console.log("Текст \\ текст 2".match(/\\/) );
    // ['\\', index: 6, input: 'Текст \\ текст 2', groups: undefined]
    // экранировать нужно и в тексте и в регулярном выражении
    // здесь получилось нагромождение косых чёрт, но благодаря этому мы можем их искать

    //  синтаксис с помощью использования new RegExp
    // С другой стороны, если мы не используем короткую запись /.../, а создаём регулярное выражение, используя new RegExp, тогда нам не нужно экранировать косую черту:
    console.log("Текст / Текст 2".match(new RegExp("/")));
    // ['/', index: 6, input: 'Текст / Текст 2', groups: undefined]

    console.log("Текст 556 Текст".match(new RegExp("\\d\\d\\d")));
    // ['556', index: 6, input: 'Текст 556 Текст', groups: undefined]
    // здесь нужно экранировать косую чёрту с помощью еще одного дополнительного слэша так как "Текст 556 Текст".match(new RegExp("\d\d\d") выдаст null

    // экранирование точки
    console.log("Текст 5.6 Текст".match(new RegExp("\\d\\.\\d")));
    // ['5.6', index: 6, input: 'Текст 5.6 Текст', groups: undefined]

  </script>
</body>
</html>