<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../css/style.css">
  <title>Пример 14 - Квантификаторы</title>
</head>
<body>

  <script>
    // Квантификаторы +, *, ? и {n}
    // Статья: https://learn.javascript.ru/regexp-quantifiers

    // Количество повторяющихся символов {n}
    console.log('#effd05 #fff #ff0000 #12abcd #Text12'.match(/#[\da-f]{6}/ig));
    // (3) ['#effd05', '#ff0000', '#12abcd']
    // Здесь ищем сначала #, после которого ищем набор [\da-f] означающий либо цифра, либо буква a-f. {6} это количество символов, и оно говорит, что ищем 6 символов которыми могут быть либо цифры, либо буквы a-f
    // #Text12 не нашел потому что диапазон букв a-f, если был бы a-z, то нашел бы.
    // используя {n} нам не нужно копировать набор 6 раз: [\da-f][\da-f][\da-f][\da-f][\da-f][\da-f] = [\da-f]{6}

    // Диапазон: {3,5}, от 3 до 5
    // Для того, чтобы найти числа от 3 до 5 цифр, мы можем указать границы в фигурных скобках: \d{3,5}

    // введя диапазон {1,2} алгоритм ищет любое число состоящее из 1 или 2 цифр по порядку, те что он уже нашел он не использует в дальнейшем поиске продвигаясь по строке слева направо
    console.log("+7(903)-123-45-67".match(/\d{1,2}/g)); // (7) ['7', '90', '3', '12', '3', '45', '67']

    // если добавить \b, то получаем:
    console.log("+7(903)-123-45-67".match(/\b\d{1,2}\b/g)); // (3) ['7', '45', '67']

    // Верхнюю границу можно не указывать.
    // Тогда шаблон \d{3,} найдёт последовательность чисел длиной 3 и более цифр/
    console.log("+7(903)-123-45-67".match(/\d{3,}/g)); // ['903', '123']

    console.log("+7(903)-123-45-67".match(/\d{1,}/g)); // (5) ['7', '903', '123', '45', '67']

    // Короткие обозначения:

    // +
    // Для самых востребованных квантификаторов есть сокращённые формы записи:
    // + Означает «один или более». То же самое, что и {1,}.
    // Например, \d+ находит числа (из одной или более цифр), и как только поиск натыкается на что-то другое кроме цифр, считается, что на этой итерации поиск числа закончен:
    console.log("+7(903)-123-45-67".match(/\d+/g)); // (5) ['7', '903', '123', '45', '67']

    // Знак вопроса ? ставится сразу после буквы, которая может быть, а может и не быть
    // Означает «ноль или один». То же самое, что и {0,1}. По сути, делает символ необязательным.
    // Например, шаблон ou?r найдёт o после которого, возможно, следует u, а затем r.
    // Поэтому шаблон colou?r найдёт два варианта: color и colour:

    console.log("Следует писать color или colour?".match(/colou?r/g)); // (2) ['color', 'colour']

    // *
    // Означает «ноль или более». То же самое, что и {0,}. То есть символ может повторяться много раз или вообще отсутствовать.
    // Например, шаблон \d0* находит цифру и все нули за ней (их может быть много или ни одного):
    console.log( "100 10 1 1222".match(/\d0*/g) ); (7) ['100', '10', '1', '1', '2', '2', '2']

    // Сравните это с + (один или более):
    console.log( "100 10 1 1222".match(/\d0+/g) ); // (2) ['100', '10']
    // 1 не подходит, т.к 0+ требует как минимум один ноль

    // Регулярное выражение для десятичных дробей (чисел с плавающей точкой): \d+\.\d+
    console.log('0 5 17.254 952,54'.match(/\d+[.,]\d+/g)); // (2) ['17.254', '952,54'] мы получили только дробные числа - числа имеющие в качестве разделителя либо точку либо запятую
    // /\d+[.,]\d+/g) означает последовательность:
    // \d+ - сначала идет цифра в количестве 1 и более
    // [.,] - затем либо одна точка либо одна запятая
    // \d+ - затем опять идет цифра в количестве 1 и более

    // Регулярное выражение для «открывающего HTML-тега без атрибутов», например, <span> или <p>:
    console.log('<body> </h1> <h1> текст 154'.match(/<\/?[a-z][a-z0-9]>*/ig)); // (3) ['<bo', '</h1>', '<h1>']
    // < - сначала должна идти угловая скобка
    // \/? - экранирование закрывающего слэша тегов /, который может быть, а может и не быть за счёт вопроса ? Этот символ понадобилось заэкранировать, чтобы JavaScript не принял его за конец шаблона.
    // первый символ в диапазоне [a-z] и он обязательно не может быть числом, поэтому чисел(0-9) в этом наборе нет
    // [a-z0-9]* второй символ либо английская буква либо цифра, и их может вообще не быть, а может быть бесконечно

    // Нахождение многоточия (3 и более точек):
    console.log('Привет. Привет.. Привет... Привет....'.match(/\.{3,}/g)); // (2) ['...', '....']
    // в результате 3 и 4 точки у нас находятся, а 1 или 2 не находятся

    // Жадные и ленивые квантификаторы
    // Статья: https://learn.javascript.ru/regexp-greedy-and-lazy

    // требуется найти текст в кавычках. Регулярное выражение вроде /".+"/g
    // где шаблон .+ обозначает «любой символ, кроме новой строки». Точка . – это специальный символьный класс, который соответствует «любому символу, кроме новой строки». Обратите внимание, что точка означает «любой символ», но не «отсутствие символа».
    // (кавычка, какой-то текст, другая кавычка) может выглядеть хорошим решением, но это не так!
    console.log('На необитаемой планете "Боннасис", система "Процион", пропали два наших исследователя.'.match(/".+"/g)); // ['"Боннасис", система "Процион"']
    // …Как мы видим, регулярное выражение работает не как задумано!
    // Вместо того, чтобы найти два совпадения "Боннасис" и "Процион", было найдено одно: "Боннасис", система "Процион".
    // Причина - по умолчанию включен жадный режим поиска регулярного движка

    // включим ленивый режим с помощью знака вопроса ?
    console.log('На необитаемой планете "Боннасис", система "Процион", пропали два наших исследователя.'.match(/".+?"/g)); // (2) ['"Боннасис"', '"Процион"']
    // обычно знак вопроса ? сам по себе является квантификатором (ноль или один), но, если он добавлен после другого квантификатора (или даже после самого себя), он получает другое значение – он меняет режим совпадения с жадного на ленивый.
    // Регулярное выражение /".+?"/g работает как задумано, оно находит "Боннасис" и "Процион":

    // Еще один вариант - Альтернативный подход
    // В нашем случаем мы можем найти кавычки без использования ленивого режима с помощью регулярного выражения "[^"]+":
    console.log('На необитаемой планете "Боннасис", система "Процион", пропали два наших исследователя.'.match(/"[^"]+"/g)); // (2) ['"Боннасис"', '"Процион"']
    // Регулярное выражение [^"]+ ищет кавычку ", за которой следует один или несколько символов «не-кавычек» [^"], а затем – закрывающая кавычка.
    // Движок регулярного выражения набирает, сколько может, [^"]+, пока не встречает закрывающую кавычку, на которой останавливается.

  </script>
</body>
</html>