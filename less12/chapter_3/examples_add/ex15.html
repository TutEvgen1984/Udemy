<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../css/style.css">
  <title>Пример 15 - Скобочные группы</title>
</head>
<body>

  <script>
    // Статья: https://learn.javascript.ru/regexp-groups
    // Часть шаблона можно заключить в скобки (...). Это называется «скобочная группа».
    // У такого выделения есть два эффекта:
    // Позволяет поместить часть совпадения в отдельный массив.
    // Если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобки, а не к одному символу.

    // сделаем поиск go+, где o+ означает любое количество o. Без скобок шаблон go+ означает символ g и идущий после него символ o, который повторяется один или более раз. Например, goooo или gooooooooo.
    console.log("go gogo goo goooo".match(/go+/g)); // (5) ['go', 'go', 'go', 'goo', 'goooo']

    // (go)+. Скобки группируют символы вместе. Так что (go)+ означает go, gogo, gogogo и т.п.
    console.log("go gogo goo goooo".match(/(go)+/g)); // (4) ['go', 'gogo', 'go', 'go']

    // домен сайта
    console.log("user.mail.ru.com users-mail.ru text".match((/([\w-]+\.)+\w+/g))); // (2) ['user.mail.ru.com', 'users-mail.ru']
    // [\w-]+ : набор либо \w (то есть любой латинский символ) либо - дефис, + означает любое количество раз
    // \. затем должна идти экранированная точка одна
    // ())+ группировка этого всего с плюсом означает любое количество повторений
    // \w+ в конце любое количество латинских букв

    // Стандартная проверка email
    console.log("email@yandex.ru @ email@mail.ru.com".match(/[\w-.]+@([\w-]+\.)+[\w-]+/g)); // (2) ['email@yandex.ru', 'email@mail.ru.com']
    // 1) [\w-.]+ : набор либо \w (то есть любой латинский символ), либо - дефис, либо точка . , + означает любое количество раз
    // 2) @ знак собаки
    // 3) ([\w-]+\.) : [\w-]+ либо символы букв либо тире и всё это много раз, затем идет отдельно \. экранированная точка, и в конце это закрывается групповыми скобками с +, то есть много раз
    // 4) [\w-]+ : набор из слов или тире много раз
    // этого метода обычно достаточно и его можно внедрить в качестве проверки на правильность ввода email. Окончательную проверку правильности email, в любом случае, можно осуществить, лишь послав на него письмо.

    // Содержимое скобок в match
    let tag = '<h1>Hello, world!</h1>'.match(/<(.*?)>/);
    console.log(tag); // (2) ['<h1>', 'h1', index: 0, input: '<h1>Hello, world!</h1>', groups: undefined]
    // <(.*?)>
    // 1) угловая скобка
    // 2) дальнейший код заключаем в круглые скобки
    // 3) точка означает любой символ (потому что она не экранирована)
    // 4) * означает любое повторение предыдущего символа
    // 5) ? то есть символ может быть и не обязательным
    // мы видим здесь массив, под нулевым индексом <h1> с треугольными скобками, под первым индексом h1
    // это потому что когда мы используем склочные группы, то они выделяются в отдельные индексы в результирующем массиве
    // то есть если нам нужен тег с треугольными скобками, то мы берём индекс 0, если нужно без, то из под индекса 1 берём. в этом удобство  групповых скобок - мы выделяем разные фрагменты кода под разные индексы

    // Если  групповые скобки не ставить, то получится так:
    console.log('<h1>Hello, world!</h1>'.match(/<.*?>/));
    // ['<h1>', index: 0, input: '<h1>Hello, world!</h1>', groups: undefined]
    // Нашёлся только <h1>

    // Вложенные группы:
    console.log( '<h1 class="title">Hello, world!</h1>'.match( /<(([a-z]+)\s*([^>]*)>)/ ) );
    // (4) ['<h1 class="title">', 'h1 class="title">', 'h', '1 class="title"', index: 0, input: '<h1 class="title">Hello, world!</h1>', groups: undefined]
    // в нулевом индексе <h1 class="title"> с угловыми скобками
    // в первом индексе тоже самое но без угловых скобок
    // для 3и4 индекса у нас не совсем правильные результаты получились: 'h', '1 class="title"' , но если указать не h1, а место него span, то все будет корректно,  тут должно выводиться отдельно название тега и отдельно его атрибуты, поэтому для h1 это выражение нужно как-то подправить
    // то же самое только с тегом span вместо h1:
    console.log( '<span class="title">Hello, world!</span>'.match( /<(([a-z]+)\s*([^>]*)>)/ ) );
    // (4) ['<span class="title">', 'span class="title">', 'span', 'class="title"', index: 0, input: '<span class="title">Hello, world!</span>', groups: undefined]
    // ([a-z]+) : любое количество букв от a до z,и все это в групповых скобках
    // \s* : любое количество пробелов, которых может не быть вообще
    // ([^>]*)) : любой символ кроме > любое количество которого может не быть, и все это в групповых скобках

    // Необязательные группы
    console.log('a'.match(/a(z)?(c)?/));
    // (3) ['a', undefined, undefined, index: 0, input: 'a', groups: undefined]
    // ищем a
    // (z)? затрём ищем z необязательный
    // (c)? затрём ищем c необязательный
    // получили массив длинной 3, 1 элемент есть и 2 undefined, даже несмотря на то что 2 необязательны  и по идее код должен был не показать эти элементы массива вообще

    console.log('az'.match(/a(z)?(c)?/));
    // (3) ['az', 'z', undefined, index: 0, input: 'az', groups: undefined]
    // получили 2 занятых элемента массива и один элемент массива имеющий значение undefined

    // Именованные группы (вместо вместо индексов 0,1,2 будут имена индексов)
    // Запоминать группы по номерам не очень удобно. Для простых шаблонов это допустимо, но в сложных регулярных выражениях считать скобки затруднительно. Гораздо лучше – давать скобкам имена.
    // Это делается добавлением ?<name> непосредственно после открытия скобки.
    let tag1 = 'azc'.match(/a(?<first>z)?(?<second>c)?/);
    // (3) ['azc', 'z', 'c', index: 0, input: 'azc', groups: {…}]
    // groups: {first: 'z', second: 'c'}
    // теперь у нас появились группы
    // вместо (z)? пишем ?<first>z. То есть ?<first> именно с вопросиком вначале и с углами, - это именно так пишется имя группы, всё остальное остается таким же.

    // теперь мы можем обратиться к  значению скобочкой группы не по номеру индекса, а по имени группы
    console.log(tag1.groups.first); // z

  </script>

</body>
</html>