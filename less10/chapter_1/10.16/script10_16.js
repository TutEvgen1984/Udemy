// * Вопрос №1/16:

// Вопрос: Для перевода числа 568 в двоичную систему подойдет метод?
// Ответ: 568..toString(2)

// Статья https://learn.javascript.ru/number

{ // Изоляция

let num = 568

console.log(num.toString(2)); // 1000111000

console.log(568..toString(2)); // 1000111000

}

/*
Внимание! Две точки в 123456..toString(36) это не опечатка. Если нам надо вызвать метод непосредственно на числе, как toString в примере выше, то нам надо поставить две точки .. после числа.

Если мы поставим одну точку: 123456.toString(36), тогда это будет ошибкой, поскольку синтаксис JavaScript предполагает, что после первой точки начинается десятичная часть. А если поставить две точки, то JavaScript понимает, что десятичная часть отсутствует, и начинается метод.

Также можно записать как (123456).toString(36).
*/


// * Вопрос №2/16:

// Вопрос: Встроенное свойство _proto_ - это...
// Ответ: И сеттер, и геттер

// Статья: https://learn.javascript.ru/prototype-inheritance
// Статья: https://learn.javascript.ru/prototype-methods
// Статья: https://learn.javascript.ru/property-accessors

// Свойство __proto__ — исторически обусловленный геттер/сеттер для [[Prototype]]

{

let animal = {
    eats: true,
    walk() {
      console.log("Animal walk"); // Animal walk
    }
  };

  let rabbit = {
    jumps: true,
    __proto__: animal // С помощью свойства __proto__ мы установили (как будто воспользовались свойством set) в объекте rabbit ссылку на animal чтобы использовать его как прототип
  };

  rabbit.walk(); // Animal walk
  // walk взят из прототипа. Когда мы обратились к этому методу JS его не нашел в объекте rabbit и пошёл искать в прототипе, нашёл там и вернул, то есть как будто сработал метод получения get

  // Про прототипы у нас написано в разделе
  // 9.11 ООП
  // Искать: console.log(`\n --- 9.11 ООП`)

}

// * Вопрос №3/16:

// Вопрос: Цикл for of может работать:
// Ответ: С итерируемыми объектами

/*
for-of - цикл по итерируемым объектам

// где iterable - это некоторый объект с методом Symbol.iterator
for (const value_variable of iterable) {
}
Перед итерацией создает итератор вызывая iterable[Symbol.iterator](), перед каждой итерацией дергает метод next у итератора, работает пока в возвращаемом из метода next объекте поле done не станет true, подставляет поле value в переменную value_variable. Цикл в примере выше можно реализовать в виде обычного for:
{
  const iter = [1, 2, 3][Symbol.iterator]();
  for (let {done, value} = iter.next(); !done; ({done, value} = iter.next())) {
    const value_variable = value;
    {
      // тело исходного цикла
    }
  }
}
*/

// Статья: https://learn.javascript.ru/iterable
// Статья: https://qna.habr.com/q/1174018
// Статья: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...of
// Статья: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Iteration_protocols#iterable

// * Вопрос №4/16:

// Вопрос: Как создать класс, который наследуется от другого класса?
// Ответ: class Dog extends Animal { }

// Статья про Наследование классов: https://learn.javascript.ru/class-inheritance
// Статья про Классы: https://learn.javascript.ru/class

{
class Animal { // создали класс Animal
  constructor(name) { // конструктор свойств объекта
    this.speed = 0;
    this.name = name;
  }
  run(speed) { // придуманный метод в классе
    this.speed = speed;
    console.log(`${this.name} бежит со скоростью ${this.speed}.`);
  }
  stop() { // ещё придуманный метод в классе
    this.speed = 0;
    console.log(`${this.name} стоит неподвижно.`)
  }
}

let cat = new Animal("Кот") // создали переменную cat в виде объекта на основе класса Animal с помощью конструкции new Animal, в скобках пишем имя желаемого животного
/* Animal { // Animal курсивом
  "speed": 0,
  "name": "Кот"
  [[Prototype]]:Object
  constructor: class Animal
  run: ƒ run(speed)
  stop: ƒ stop()
} */
cat.run(5) // Кот бежит со скоростью 5.
cat.stop() // Кот стоит неподвижно.

class Dog extends Animal { // создали класс Dog, который наследуется от класса Animal
  hide() { // написали дополнительный метод для класса Dog, тем самым расширив класс Dog в сравнении с Animal
    console.log(`${this.name} прячется!`)
  }
}

let dog = new Dog ("Бим") // создали переменную dog в виде объекта на основе класса Dog с помощью конструкции new Dog, в скобках пишем имя желаемого животного

dog.run(5) // Бим бежит со скоростью 5.
dog.stop() // Бим стоит неподвижно.
dog.hide() // Бим прячется!

// Про классы у нас написано в разделе
// 9.11 ООП
// Искать: console.log("\n --- Классы:");

}

// * Вопрос №5/16:
// Вопрос: Math.random() возвращает число в диапазоне:?
// Ответ: от 0 до 1

// Math обязательно с большой буквой. с помощью random() мы сгенерируем случайное число от 0 до 1 не включая единицу, при этом нужно обязательно ставить скобки,  возвращаемое при помощи Math.random() может быть 0, но никогда не будет равно 1

// Статья: https://doka.guide/js/math-random/

// * Вопрос №6/16:
// Вопрос: С помощью какой функции можно отбросить дробную часть и оставить только целую часть числа?
// Ответ: Math.trunc

// Статья: https://doka.guide/js/math-floor/

// * Вопрос №7/16:
// Вопрос: Как назначить функцию fn обработчиком нажатия на элемент element?
// Ответ: element.onclick = fn

// Статья: https://doka.guide/js/element-click/
// Статья: https://doka.guide/js/events/

// Существует два способа обработать события:
// 1) с помощью on-свойств DOM-элементов;
// 2) методом addEventListener().

/* on-свойства DOM-элементов
Большинство событий связаны с DOM-элементами. Если пользователь кликнул на кнопку, то событие click связано с конкретным DOM-элементом — кнопкой, на которой кликнул пользователь.

Каждый DOM-элемент имеет большой набор свойств, которые начинаются на on:
- onclick;
- onscroll;
- onkeypress;
- onmouseenter;
и так далее.
Если в это свойство записать анонимную функцию, то эта функция будет вызываться каждый раз, когда браузер будет создавать событие, связанное с этим элементом. Такие функции называют функциями-обработчиками события.

Есть недостаток. Если обрабатывать события с помощью on-свойств, то получится добавить только одну функцию-обработчик на каждый элемент. Часто одного обработчика недостаточно. Чтобы не создавать ограничение на пустом месте, используют альтернативный метод подписки на события — метод addEventListener().*/

{

const element = document.getElementById('btn1')
element.onclick = function () {
  console.log("Щёлк"); // получили Щëлк несколько раз
}

}

// * Вопрос №8/16:
// Вопрос: Что вернёт 'foo' + + 'bar'??
// Ответ: 'fooNaN'

// Статья: https://learn.javascript.ru/operators

// Сложение строк при помощи бинарного +
// Обычно при помощи плюса '+' складывают числа.
// Но если бинарный оператор '+' применить к строкам, то он их объединяет в одну:

{

let s = "моя " + "строка";
console.log(s); // моя строка

let Q8 = 'foo' + + 'bar'
console.log(Q8); // fooNaN

console.log(+ 'bar'); // Получили: NaN. Это потому, что JS попытался преобразовать к числу строку 'bar'

}

// здесь 'foo' - это строка
// два оператора ++ это на самом деле сначала +'bar' в котором унарный + применяется к строке 'bar'.
// Унарный, то есть применённый к одному значению, плюс + ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.

// В итоге к строке foo присоединяем строковый NaN (который получился в результате попытки выполнить + 'bar')

// * Вопрос №9/16:
// Вопрос: Может ли использоваться деструктуризация в объявлении функции в блоке перечисления аргументов (то есть, в круглых скобках, перед телом функции)?
// Ответ: Да

// Статья: https://learn.javascript.ru/destructuring-assignment

{

let options = {
  title: "Menu",
  height: 200,
  width: 100
};

function showMenu({ title = "Menu", width = 300, height = 300 } = {}) {
  console.log( `${title} ${width} ${height}` );
}

showMenu(options); // Menu 100 200

console.log(options['title']); // Menu

console.log('\n');

for (const prop in options) {
  console.log(prop, options[prop])
}
// title Menu
// height 200
// width 100

console.log('\n');

}

// При вызове функции в не в качестве и аргумента передаётся объект options
// Но в качестве аргумента у нас не объект, как мы обычно это делали, а  сразу деструктуризация, которая применится к объекту и внутрь функции передадутся 3 переменные title, width, height
// Для потенциально отсутствующих свойств мы можем установить значения по умолчанию, используя "=". title = "Menu" означает, что если в переданном объекте не будет свойства title, то ей присвоится значение = "Menu".
// В приведённом выше коде весь объект аргументов по умолчанию равен {} на случай, если не передать объект в функцию, поэтому всегда есть что-то, что можно деструктурировать.

// * Вопрос №10/16:
// Вопрос: У какого оператора приоритет выше?
// Ответ:
// - (умножение *) (Приоритет 12)
// - У этих операторов равный приоритет
// - ** (возведение в степень). -- Этот ответ правильный потому что приоритет 13 --

// Статья: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_precedence

console.log(3**2*2); // Получили: 18. Сначала 3 возводится в степень 2, получаем 3*3=9, затем полученная 9 * 2 = 18

// * Вопрос №11/16:
// Вопрос: Как очистить session storage?
// Ответ: sessionStorage.clear()

// Статья: https://doka.guide/js/session-storage/
// Статья: https://learn.javascript.ru/localstorage

// Метод clear() очищает хранилище полностью.
// window.sessionStorage.clear()

// * Вопрос №12/16:
// Вопрос: Как получить массив с ключами объекта obj?
// Ответ: Object.keys(obj) – возвращает массив ключей.

// Статья: https://learn.javascript.ru/keys-values-entries

{
let user = {
  name: "John",
  age: 30
};

keys = Object.keys(user)
console.log("🚀 ~ keys:", keys) // (2) ['name', 'age']

console.log(Object.keys(user)); // (2) ['name', 'age']
console.log(Object.values(user)); // (2) ['John', 30]
console.log(Object.entries(user)); // [ ["name","John"], ["age",30] ]

}

// * Вопрос №13/16:
// Вопрос: Какого типа данных нет в JS?
// Ответ:
// - Symbol (есть)
// - Char (такого типа данных нет)
// - Bigint (есть)
// - Null (есть)

// Статья: Короткое видео про типы данных на JS (Дзен) https://dzen.ru/video/watch/66cefefc33c5f324853bc06c
// Статья: https://learn.javascript.ru/types
// Статья: https://doka.guide/js/symbol/

// ! В JS Нет отдельного типа данных для одного символа.
/* В некоторых языках, например C и Java, для хранения одного символа, например "a" или "%", существует отдельный тип. В языках C и Java это char.
В JavaScript подобного типа нет, есть только тип string. Строка может содержать ноль символов (быть пустой), один символ или множество.
*/


/* JavaScript есть 8 основных типов данных.

Семь из них называют «примитивными» типами данных:
1) number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
2) bigint для целых чисел произвольной длины.
3) string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
4) boolean для true/false.
5) null для неизвестных значений – отдельный тип, имеющий одно значение null.
6) undefined для не присвоенных значений – отдельный тип, имеющий одно значение undefined.
7) symbol для уникальных идентификаторов в объектах.
8) И один не является «примитивным» и стоит особняком:
object для более сложных структур данных.
 */

// Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:
// символ "n" в конце означает, что это BigInt
// const bigInt = 1234567890123456789012345678901234567890n;

// Специальное значение null не относится ни к одному из типов, описанных выше.
// Оно формирует отдельный тип, который содержит только значение null:
// let age = null;
// В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.
// Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
// В приведённом выше коде указано, что значение переменной age неизвестно.
// typeof null // "object"  (2)
// Результатом вызова typeof null является "object". Это официально признанная ошибка в typeof, ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, null не является объектом. Это специальное значение с отдельным типом.

// * Вопрос №14/16:
// Вопрос: Как удалить элемент из localStorage?
// Ответ: localStorage.removeItem("name")

// Статья: https://doka.guide/js/local-storage/
// Статья: https://learn.javascript.ru/localstorage

// Удаляет запись из хранилища removeItem('ключ'). Он успешно выполнится, даже если указанного ключа не существует в хранилище.

{

window.localStorage.removeItem('name')

}

// * Вопрос №15/16:
// Вопрос: Разрешены ли дефисы в именах переменных?
// Ответ: 

// Статья: https://learn.javascript.ru/variables
// Статья: https://html5css.ru/js/js_conventions.php

{

// let my-name; // дефис '-' не разрешён в имени (раскомментировать для проверки)

}