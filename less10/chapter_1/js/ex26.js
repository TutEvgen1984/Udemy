// * Код из обучения от автора курса Исмаила:
for (let key in PHONE_NUMBER) { // пройдемся по ключам объекта (это то, что написано до двоеточий: Группа номеров 1, 2, 3)
    let row = document.createElement('tr')
    row.innerHTML = `<th colspan="2">${key}</th>`  /* создали заголовок поместив в него значение ключа с объединением 2-ух столбцов */
    document.querySelector('table').append(row) // вставляем в таблицу получившийся ряд заголовка на каждом цикле

    for (let i = 0; i < PHONE_NUMBER[key].length; i++) { // в первом случае (первый ключ) от 0 до 3 (3 раза), во втором 1 раз, в 3-ем 2 раза
      let row = document.createElement('tr') // переменная названием такая же, но так как она существует временно только в пределах лексического окружения текущего цикла for, то никакого конфликта не будет. этот второй повторный 'tr' будет дочерним относительно первого
      row.innerHTML = `
          <td>${PHONE_NUMBER[key][i][0]}</td>
          <td>${PHONE_NUMBER[key][i][1]}</td>`
      // PHONE_NUMBER[key][i][0] = [Группа номеров 1][Ряд 0 (из трёх)][0 ( взять нулевой элемент из массива в который забрались = 'Номер 1' ) ]
      // PHONE_NUMBER[key][i][1] = [Группа номеров 1][Ряд 0 (из трёх)][1 ( взять первый элемент из массива в который забрались = '2591514' ) ]
      document.querySelector('table').append(row)
      // засовываем получившийся ряд в таблицу ниже вслед за рядом th который добавляли выше
    }
  }

  // * Код из обучения из комментариев от Vladislav Vagner:
  // Могу предложить альтернативный код. Лично мне более понятней использовать цикл forEach
  function using_method_forEach() { // изолируем код
    for (let key in PHONE_NUMBER) {
      let row = document.createElement('tr')
      row.innerHTML = `<th colspan="2">${key}</th>`
      document.querySelector('table').append(row) // вставляем в таблицу получившийся ряд заголовков

      PHONE_NUMBER[key].forEach(element => { // метод foEach автоматически определил сколько всего существует элементов массива в PHONE_NUMBER[key] ([Группа номеров 1]) и начав перебирать первый элемент массива считает как переменная element ( ['Номер 1', '2591514'] ), при следующем цикле forEach это уже будет второй элемент массива
        let row = document.createElement('tr')
        row.innerHTML = `
        <td>${element[0]}</td>
        <td>${element[1]}</td>`
        // element[0] = ['Номер 1', '2591514'][0 ( взять нулевой элемент из массива в который забрались = 'Номер 1' ) ]
        // element[1] = ['Номер 1', '2591514'][1 ( взять первый элемент из массива в который забрались = '2591514' ) ]
        document.querySelector('table').append(row)
        // засовываем получившийся ряд в таблицу ниже вслед за рядом th который добавляли выше
      })
    }
  } // конец изоляции

  // В итоге этот код универсальный в том плане, что мы модем изменять данные внутри const PHONE_NUMBER с учетом того, что групп может быть сколько угодно, в каждой группе может быть сколько угодно массивов, но с одним условием, что в конечном массиве данных будет именно по 2 элемента массива. Можно менять номера телефонов, добавлять группы и тому подобное, и всё у нас будет работать универсально.

  // ? Вопрос: В какой последовательности нужно использовать методы?
    // Ответ:
    // Чтобы:
    // Найти элемент - querySelector
    // Создать новый - createElement
    // Записать в него текст - innerHTML

