<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../css/style.css">
  <title>Пример 22</title>
</head>
<body>

  <div class="alert">
    <p>Пример 22</p>
  </div>

  <div class="alert">
    <p>Второй DIV</p>
  </div>

  <script>
    let div_element = document.querySelector('div')
    // let div_element = document.querySelector('.alert')  // Это метод подцепления к классу через querySelector, при этом надо обязательно перед название класса ставить точку 
    // let div_element = document.querySelectorAll('.alert')[0] // [0] здесь как бы преобразует полученную коллекцию в массив и берёт от туда нулевой элемент
    // let div_element = document.getElementsByClassName('alert')[0] //  Это метод подцепления к классу через etElementsByClassName. При этом нам возвращается коллекция HTMLCollection[1] которая так сразу не работает и в дальнейшем вылетит ошибка, необходимо указать квадратные скобки и ноль тем самым как бы преобразовав коллекцию в массив и взяв от туда нулевой элемент, при этом при названии класса точку писать не надо. И тогда работает всё без ошибок в дальнейшем
    div_element.style.color = "purple" // с помощью ключевого слова style и ключа color присвоили пурпурный цвет шрифту
    // style это встроенный в html стиль, когда в атрибуте любого элемента пишем style="" (который в том виде следует избегать так как он нарушает принцип разделения кода и оформления, но так как мы сейчас в JS, то так можно из JS делать)  
    div_element.style.width = '300px' // уменьшили ширину до 300 пикселей вместо ширины на всю страницу по умолчанию применяющегося для блочного div
    div_element.style.backgroundColor = prompt('Цвет', "tomato") // "tomato" это цвет по умолчанию, который будет уже написан в поле и останется только ОК нажать
    // backgroundColor в JS пишется стилем CamelStyle, а не через дефис как было в CSS
    div_element.style.display = 'none' // это мы скрыли полностью элемент div
    setTimeout(() => div_element.style.display = '', 3000);
    // пустые кавычки означают, что значение display вернётся в изначальное состояние, даже если мы не знаем какое оно было (блок, флекс и прочее)
    // в итоге сначала JS идя по коду скрывает элемент div, а затем через 3 сек возвращает ему значение по умолчанию
    console.log(div_element.style.color); // получили purple

    // Существует специальная функция getComputedStyle для получения ФИНАЛЬНЫХ стилей (computed англ. вычисленный)
    let style_element = getComputedStyle (div_element)
    console.log(style_element.color); // получили rgb(128, 0, 128) он отличается написанием от purple , то есть он в формате RGB выводится при таком способе
    console.log(style_element); // получили CSSStyleDeclaration раскрывающийся, в котором просто куча свойств написана, и ещё куча свойств при раскрытии появляется
    // это уже рассчитанные финальные значения для стилей, которые могут комбинироваться. 
    // Например у нас может быть отдельный css файл, а может быть и несколько, из которых одни стили применяются, затем у нас может в head внутренний стиль быть и он что-то может добавлять, плюс может быть встроенный стиль для элементов, и как это всё и где искать и самому вычислять что где и с чем сложилось. getComputedStyle нужен именно для этого
    // getComputedStyle позволяет использовать именно те стили, которые у нас будут в финальном результате получаться, которые мы видим уже на финальной html-странице в разделе Исследовать элемент
    // Это полезно работать с рассчитанными стилями, а не с теми которые у нас напечатаны, потому что они могут отличаться, у стилей есть приоритеты (одни стили могут переопределять другие). И в таком случае getComputedStyle позволяет использовать те финальные стили, которые у нас применятся к элементу    
    

  </script>

</body>
</html>