<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../css/style.css">
  <title>Пример 23 - Метрики</title>
</head>
<body>

  <main style="position: relative;" id="main">  <!-- тэг main https://doka.guide/html/main/ -->
    <div id="example" style="
      position: absolute;
      left: 150px; /* метрика offsetLeft покажет текущее свойство */
      top: 120px; /* метрика offsetTop покажет текущее свойство */
      width: 350px; /* метрика offsetWidth покажет текущее свойство */
      height: 150px; /* метрика offsetHeight покажет текущее свойство */
      border: 10px solid black;
      padding: 15px;
    ">Lorem ipsum dolor sit amet consectetur adipisicing elit. Tenetur pariatur et animi blanditiis sapiente excepturi, aut modi dignissimos nisi veniam eveniet repellendus debitis similique porro non! Doloribus accusantium dolores nobis maxime eaque ut corporis est. Nobis quibusdam voluptatum suscipit accusamus necessitatibus nesciunt animi! Ullam autem eos error dolore adipisci repellendus itaque dolorem quod maxime quasi illum cumque eaque, architecto consequatur recusandae praesentium, consequuntur magni, omnis quam molestias labore. Voluptatibus, laborum sequi aliquid sed amet voluptatum fugit optio ipsam ex quam omnis ea, consequatur est sit explicabo mollitia maiores. Quis suscipit ipsam nisi maiores deserunt consectetur totam dolores et quo expedita?</div>
  </main>

  <script>
    // --- Метрика №1 offsetParent(внешний родитель): ---
    console.log(example.offsetParent); // Получили в консоли весь код с html-страницы <main style="position: relative;" id="main"> и так далее
    // здесь мы ввели идентификатор example и через точку дальше метод offsetParent (offset англ. - смещение; Parent англ. - родитель; offsetParent - офсетный родитель, ближайший внешний родитель, сместиться к родителю)
    // получили мы ближайший элемент main потому что он самый ближайший родитель для div с идентификатором example, ближайший в плане расстояния до него

    // --- Метрика №2 offsetLeft(внешннее расстояние слева): ---
    console.log(example.offsetLeft); //  получили 150, это 150 пикселей
    //  это у нас расстояние слева от нашего тэга main до нашего тэга, на котором мы применяем это свойство

    // --- Метрика №3 offsetTop(внешннее расстояние сверху): ---
    console.log(example.offsetTop); // получили 120, это 120 пикселей
    //  это у нас расстояние сверху от нашего тэга main до нашего тэга, на котором мы применяем это свойство

    // --- Метрика №4 offsetTop(внешняя ширина): ---
    console.log(example.offsetWidth); // получили 400, это 350+(10+10 border)+(15+15 padding) пикселей
    //  это у нас ширина элемента включая рамки нашего элемента и паддинги

    // --- Метрика №5 offsetHeight(внешняя высота): ---
    console.log(example.offsetHeight); // получили 200, это 150+(10+10 border)+(15+15 padding) пикселей
    //  это у нас ширина элемента включая рамки нашего элемента и паддинги

    // эти все отступы можно увидеть в исследовании элемента нажав кнопку со специальной стрелочкой и затем наведя на элемент страницы

    // --- Метрика №6 clientLeft(клиент слева): ---
    console.log(example.clientLeft); // получили 10, эта ширина равна ширине border
    //  это расстояние от внешнего угла до внутреннего, оно равно у нас границе border слева

    // --- Метрика №7 clientTop(клиент сверху): ---
    console.log(example.clientLeft); // получили 10, эта ширина равна ширине border
    // это расстояние от внешнего угла до внутреннего, оно равно у нас границе border сверху, и так как у нас border со всех сторон равен 10, то получаем опять те же 10
    // это не то же самое что и border, но в большинстве случаев оно возвращает такой результат
    // а если текст у нас будет арабский справа налево, то оно прибавит ширину прокрутки и в этом случае оно и пригодится, но это достаточно редкий случай

    // --- Метрика №8 clientTop(клиент ширина): ---
    console.log(example.clientWidth); // получили 380, это 350+(15+15 padding) пикселей
    // это ширина с учетом ширины пэддингов (без border)

    // --- Метрика №9 clientHeight(клиент высота): ---
    console.log(example.clientHeight); // получили 180, это 150+(15+15 padding) пикселей
    //  это высота с учетом высоты и пэддингов (без border)

    // но здесь не учитывается полоса прокрутки

    // --- Метрика №10 scrollWidth(прокрутка ширина): ---
    console.log(example.scrollWidth); // получили 380, это 350+(15+15 padding) пикселей
    // позволяет получить ширину содержимого учитывая прокручиваемую невидимую область элемента   

    // --- Метрика №11 clientTop(прокрутка высота): ---
    console.log(example.scrollHeight); // получили 319, это ?
    // позволяет получить высоту содержимого учитывая прокручиваемую невидимую область элемента

    // то есть если у элемента есть прокрутки по горизонтали и по вертикали, то все что мы прокрутили и оно исчезло из области видимости

    // и последние две метрики это:
    // scrollLeft и scrollTop дадут нам в данном случае 0, но они позволяют получить ширину и высоту прокрученной части элемента

    // Эта тема с метриками достаточно сложная и не всегда понятно где её можно применить, и возможно вы сейчас задумываетесь зачем нужны эти сложные метрики если можно получить все эти значения - padding, border. высота и ширина - получить из CSS. Но это не всегда бывает корректно если вы получите что-то из CSS, у вас элемент на странице может совсем в другом месте находиться так как вычисленные в результате его значения позиции могут суммироваться в зависимости от приоритетов разных стилей и могут в итоге применяться совсем другие стили, а не те, которые были указаны в файле CSS. Поэтому если нужно точно знать где находится элемент используются эти метрики. Они как и getComputedStyle позволяют рассчитать разные значения позиции элемента уже в конечном вариант. Эти метрики можно рассчитать значения для того чтобы разместить какой-то новый элемент на странице.

  </script>
</body>
</html>