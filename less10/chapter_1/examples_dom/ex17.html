<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../css/style.css">
  <title>Пример 17 - Дерево списков</title>
</head>

<body>

  <script>
    let data = { // Это сложный объект, в котором 2 основных объекта (2 раздела),в первом из которых 2 "ключ-значение", а во втором объекте 2 объекта, и у каждого по 2 "ключ-значение"/ В качестве значений могут быть другие объекты, смотри https://doka.guide/js/object/
      "Овощи": { // Объект №1
        "огурцы": 5, // ключ-значение №1.1
        "помидоры": 3 // ключ-значение №1.2
      },
      "Фрукты": { // Объект №2
        "красные": { // Объект №2.1
          "клубника": 2, // ключ-значение №2.1.1
          "малина": 4 // ключ-значение №2.1.2
        },
        "зеленые": { // Объект №2.2
          "яблоко": 6, // ключ-значение №2.2.1
          "лайм": 2 // ключ-значение №2.2.2
        }
      }
    }
    // Внеплановые строки кода:
    // console.log(Object.keys(data).length);
    // Получили 2 // это видимо Овощи 1 и Фрукты 2

    // let data2 = {}
    // console.log(Object.keys(data2).length); 
    // Получили 0

    console.log(data["Овощи"]);
    // Получили: {"огурцы": 5, "помидоры": 3} // В качестве ключа у нас объект Овощи, в качестве значения у нас выводится не значение присвоенное ключу, а все "ключи-значения" объекта
    console.log(isNaN(data["Овощи"])); // Получили true потому что это не число
    console.log(!isNaN(data["Овощи"])); // Сейчас получили false. Из-за ! мы получим true если будет в качестве значения число, что будет означать, что мы внизу по иерархии объекта.

    function createUl(objElement) {
        if (!Object.keys(objElement).length)  // Если в объекте length = 0, то есть НЕТ ключей (!Есть ключи). В нашем случае length = 2, получаем false. 
          return // тогда мы выходим из функции так как при отсутствии ключей length = 0 и в условии получим true
        // Чтобы узнать какие существуют ключи у объекта, существует следующая конструкция: пишем Object.keys и в скобках имя нашего объекта. При этом Object пишется с большой буквы
        let ulElement = document.createElement('ul') // Создадим пустой элемент ul
        for (let key in objElement) { // циклом проходимся по всем ключам объекта. key - это текущий ключ в объекте
          let liElement = document.createElement('li') // создаем пункт списка
          if (!isNaN(objElement[key])) // Проверяем: значение ключа - является ли оно числом. Если это число, то это значит, что это конечный пункт, и делаем следущее
            liElement.textContent = key + objElement[key] // в строку списка в качестве текста вносим название ключа + значение ключа
          else // то есть если проверка показала, что это НЕ число
          liElement.textContent = key // в строку списка в качестве текста вносим название ключа
          let childrenUL = createUl(objElement[key]) // Это рекурсивная функция потому, что она вызывывается внутри себя. В качестве значения функции мы теперь передаем objElement[key] (вместо objElement который мы передавали раньше) - то есть мы уходим на 1 уровень глубже. И функция сделает с ним все то же самое для вложенного нашего объекта.  
          // То есть если в нашем объекте содержется не число, а например другой объект, то мы для него будем выполнять рекурсивный вызов функции. И так до тех пор, пока не встретится число, и это будет означать что мы напечатаем ключ с числом, которое с ним рядом установлено. И тем самым мы вывели какой-то вложенный ul.
          if (childrenUL) {  //  Если childrenUL существует (дочерний ul может и не создаться)
            liElement.append(childrenUL)  //  То мы в наш liElement с помощью. append добавляем childrenUL
          }
          ulElement.append(liElement)
        }
        return ulElement
    }

     // Далее нам нужно вывести это на html-страницу
     // Напишем функцию, которая будет создавать дерево 
    function createTree(container, obj) { // container - это место на html-странице куда вставится дерево, obj - это объект на основе которого будет строиться дерево
      document.querySelector(container).append(createUl(obj))
    }
       // выбрали дерево с помощью querySelector(container) место втсавки на html-странице
       // append(createUl(obj) - и поместили методом append внутрь контейнера функцию createUl(obj), которая преаратиться потмо в return ulElement

       createTree('body', data) // Вызываем функцию createTree чтобы эта функция выполнилась
       // В качестве первой переменной передаём любой CSS-селектор, например body
       // В качестве второй переменной передаём наш объект data
  </script>
</body>
</html>