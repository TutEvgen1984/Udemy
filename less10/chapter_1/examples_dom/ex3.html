<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Пример 3 - в списке замена текста на ссылку</title>
</head>
<body>
  
  <ul>
    <li>Пункт 1</li> <!-- Получили: <li><a href='#'>Ссылка</a></li> -->
    <li>Пункт 2</li> <!-- без изменений -->
    <li>Пункт 3</li> <!-- без изменений -->
  </ul>
  

  <script>
    const element = document.querySelector('ul > li') /* выберется только один первый пункт li */
    element.innerHTML = "<a href='#'>Ссылка</a>" // Получили ссылку вместо Пункт 1. 
    // Здесь мы изменили свойство константы элемента, а не сам элемент, поэтому всё изменилось без каких-либо ошибок. в свойстве innerHTML можно указывать не только ТЕКСТ, но ещё и тэги, и здесь мы поместили внутрь <li>Пункт 1</li> ссылку и получили <li><a href='#'>Ссылка</a></li> 
    
    // element = document.querySelector('ul') // попытка изменить element приводит к появлению ошибки в консоли: "Ошибка: Uncaught TypeError: Assignment to constant variable."
    
    // метод поиска querySelector выбирает первый элемент и на этом сразу же останавливается в отличии от querySelectorAll, который работает дольше и ищет все элементы, которые подходят селектору. querySelector находит первый и прекращает свою работу. Поэтому если нам нужно найти какой-то один элемент, то лучше использовать querySelector потому что он работает намного быстрее.

    // querySelector и querySelectorAll поддерживаются всеми браузерами, они позволяют легко выбирать элементы и не приходится везде всё метить идентификаторами. getElementById почти никто не использует, но тем не менее он более менее актуален и его можно использовать. 
    // остальные методы поиска getElementsByClassName — поиск элементов по названию класса; getElementsByTagName — поиск элементов по названию тега; в данном случае не будем изучать, потому что всё это можно выбрать по CSS селектору с помощью querySelector.
  </script>
</body>
</html>