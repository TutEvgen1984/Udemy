<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Пример 2 - в ul смена цвета шрифта и замена текста</title>
</head>
<body>
  
  <ul>
    <li>Пункт 1</li> <!-- этот элемент поместится в переменную elements -->
    <li>Пункт 2</li>
  </ul>
  <ul>
    <li>Пункт 3</li> <!-- этот элемент поместится в переменную elements -->
    <li>Пункт 4</li> 
  </ul>
  <ul>
    <li>Пункт 5</li> <!-- этот элемент поместится в переменную elements -->
    <li>Пункт 6</li>
  </ul>
  <ul>
    <li>Пункт 7</li> <!-- этот элемент поместится в переменную elements -->
    <li>Пункт 8</li> 
  </ul>

  <script>
    let elements = document.querySelectorAll('ul > li:first-child') // query = англ. запрос. querySelectorAll() — поиск всех дочерних элементов подходящих под CSS-селектор. Здесь мы в документе хотим получить ВСЕ элементы по CSS селектору, а не по идентификатору. Поместили в переменную из всего документа из каждого немаркированного списка(ul) элемент, но только первый (li:first-child) за счет псевдо-класса first-child. https://doka.guide/js/query-selector-all/

    console.log(elements);
    // ввели в консоль elements, получили "NodeList(4) [li, li, li, li]" который если открыть то видим:
    // 0: li
    // 1: li
    // 2: li
    // 3: li
    // length: 4
    // [[Prototype]]: NodeList

    // NodeList : node англ. - узел, list - англ. список, NodeList = Список Узлов. NodeList это не массив, это коллекция - сущность, которая похожа на массив объектов, но при этом им не является, на самом деле это набор DOM-элементов. NodeList — коллекция узлов, более абстрактное понятие. Например, в DOM-дереве есть не только узлы-элементы, но также текстовые узлы, узлы-комментарии и другие, поэтому NodeList может содержать другие типы узлов.   https://habr.com/ru/companies/htmlacademy/articles/554776/
    let count = 0 // глобальное лексическое окружение
    for (let element of elements) { // пройдемся по каждому элементу массива циклом
      element.style.color = 'gray' // цвет шрифта изменяем на серый
      element.innerHTML = 'Новое значение'  /* С помощью свойства innerHTML читаем и изменяем содержание HTML-элемента. Вместо пункт 1,3,5,7 вставим новое содержимое внутри тэга (в нашем случае это тэг li каждый первый). При чтении, это свойство возвращает HTML-код всего, что вложено в текущий элемент. При записи в это свойство, предыдущее содержимое будет затёрто, и страница отобразит новое содержимое. Свойство innerHTML позволяет считать содержимое элемента в виде HTML-строки или установить новый HTML.
      https://doka.guide/js/element-innerhtml/ */
      count = 55 // изменили переменную
      var count_2 = 88 // создали переменную внутри цикла через ver, она создатся снанужи цикла в глобальном окружении
      let count_3 = 23 // создали переменную внутри цикла через let, её не будет видно снаружи цикла
    }
    // Получили: 
      // <li style="color: gray;">
      // ::marker
      // "Новое значение:
      // </li>
      console.log(count); // Получили 55
      console.log(count_2); // Получили 88
      console.log(count_3); // count_3 is not defined
  </script>
</body>
</html>