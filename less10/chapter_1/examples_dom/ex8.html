<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Пример 8 - textContent</title>
</head>
<body>
  
  <p>Абзац текста</p>
  <div>
    <h3>Заголовок</h3>
    <p>Текст</p>
  </div>

  <script>
  // ---- textContent. Текстовое содержимое: ---
      
  let strs = ["Фамилия", "Имя", "Отчество"]
  document.querySelector('p').textContent = `
  <p>${strs[0]} - ${strs[1]} - ${strs[2]}</p>
  `
  // Получили "<p>Фамилия - Имя - Отчество</p>" в первом абзаце вместо "Абзац текста". При этом абзац, который дальше в div, не был затронут. Отличие от innerHtml в том, что тут нельзя писать никакие html-тэги, они будут вставлены как текст, что видно на результате

  console.log(document.querySelector('div').textContent);
  // Получили в консоли:
  // Заголовок
  // Текст
  // Свойство textContent НЕ сохраняет структуру тэгов

  console.log(document.querySelector('div'));
  // Получили в консоли:
  // <div>
  //   <h3>Заголовок</h3>
  //   <p>Текст</p>
  // </div>

  console.log(document.querySelector('div').innerHTML);
  // Получили в консоли:
  // <h3>Заголовок</h3>
  // <p>Текст</p>
  // Свойство innerHTML сохраняет структуру тэгов

  // То есть свойство textContent возвращает только текст без элементов html. 
  // Свойство textContent позволяет считывать или задавать текстовое содержимое элемента. Обращение к свойству вернёт строку, которая будет состоять из текстового содержимого всех вложенных элементов, даже если они скрыты с помощью CSS и не видны на экране.
  // Аналогичной функциональностью, но с некоторыми ограничениями обладает свойство innerText. Оно работает так же, но не включает в себя скрытые элементы.
  // https://doka.guide/js/element-textcontent/



  </script>
</body>
</html>